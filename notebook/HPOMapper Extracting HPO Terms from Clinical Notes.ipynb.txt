{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "661a903c-d7f9-4cf1-b986-771b7c4ac109",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 1 - Import necessary libraries and modules\n",
    "# hpomapper: Extracting HPO Terms from Clinical Notes\n",
    "# ====================================================\n",
    "\n",
    "# This notebook demonstrates the full workflow of hpomapper:\n",
    "# 1. Setting up the environment\n",
    "# 2. Vectorizing the HPO database (if needed)\n",
    "# 3. Running hpomapper on clinical notes\n",
    "# 4. Analyzing and visualizing the results\n",
    "\n",
    "import os\n",
    "os.chdir(\"../src\")\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from tqdm import tqdm\n",
    "import json\n",
    "import sys\n",
    "from pathlib import Path\n",
    "from IPython.display import display, clear_output\n",
    "import ipywidgets as widgets\n",
    "\n",
    "# Add current directory to path to import hpomapper modules\n",
    "sys.path.append('.')\n",
    "\n",
    "# Import hpomapper modules - make sure these match your actual file names\n",
    "from hpomapper_main import HPOVectorDB, BedrockLLM, hpomapper, parse_hpo_json\n",
    "from hpo_vectorization import HPOVectorizer, create_test_embeddings_file\n",
    "\n",
    "# Import AWS credential helper\n",
    "import aws_helper\n",
    "import logging\n",
    "\n",
    "# Configure logging\n",
    "logging.basicConfig(level=logging.INFO,\n",
    "                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n",
    "\n",
    "# Global variables for data filtering and processing\n",
    "df = pd.DataFrame()\n",
    "mrn_filtered_df = pd.DataFrame()\n",
    "encounter_filtered_df = pd.DataFrame()\n",
    "final_filtered_df = pd.DataFrame()\n",
    "notes_dir = ''\n",
    "filtered_mrn = None\n",
    "hpomapper_input_file = None\n",
    "\n",
    "# Define the HPO embedding file path\n",
    "hpo_embedding_file = '../db/G2GHPO_metadata.npy'"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9996084-a97f-4300-8ce4-d58ab6ecf340",
   "metadata": {},
   "source": [
    "## 1. Setting up the environment\n",
    "First, let's make sure we have the necessary files and AWS credentials"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "f67467fb-4c7b-4c89-85f9-cc3c877e8cb1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 2 - Data Loading and Filtering Functions\n",
    "\n",
    "def initialize_extraction():\n",
    "    \"\"\"Initialize the data extraction process with UI components\"\"\"\n",
    "    global df, notes_dir\n",
    "    \n",
    "    # Default paths - adjust these as needed\n",
    "    data_csv_path = '../data/randome_asd_notes_cleaned3.csv'\n",
    "    notes_dir = '../data/notes/extracted_notes_ind_mrn'\n",
    "    \n",
    "    # Create a file path input widget\n",
    "    csv_path_input = widgets.Text(\n",
    "        value=data_csv_path,\n",
    "        placeholder='Path to CSV file',\n",
    "        description='CSV Path:',\n",
    "        layout={'width': '80%'},\n",
    "        style={'description_width': 'initial'}\n",
    "    )\n",
    "    \n",
    "    # Create an output directory input widget\n",
    "    output_path_input = widgets.Text(\n",
    "        value='../data/notes/extracted_notes_ind_mrn',\n",
    "        placeholder='Path to output directory for notes',\n",
    "        description='Notes Path:',\n",
    "        layout={'width': '80%'},\n",
    "        style={'description_width': 'initial'}\n",
    "    )\n",
    "    \n",
    "    # Create a load button\n",
    "    load_button = widgets.Button(\n",
    "        description='Load CSV',\n",
    "        button_style='primary'\n",
    "    )\n",
    "    \n",
    "    # Create an output widget for messages\n",
    "    load_output = widgets.Output()\n",
    "    \n",
    "    # Define the button click handler\n",
    "    def on_load_button_click(b):\n",
    "        global df, notes_dir\n",
    "        with load_output:\n",
    "            clear_output()\n",
    "            try:\n",
    "                # Set paths based on user input\n",
    "                data_csv_path = csv_path_input.value\n",
    "                notes_dir = output_path_input.value\n",
    "                \n",
    "                # Create output directory\n",
    "                os.makedirs(notes_dir, exist_ok=True)\n",
    "                \n",
    "                # Load the CSV file\n",
    "                print(f\"Loading data from {data_csv_path}...\")\n",
    "                df = pd.read_csv(data_csv_path)\n",
    "                print(f\"Successfully loaded {len(df)} records from CSV.\")\n",
    "                print(f\"Notes will be saved to: {notes_dir}\")\n",
    "                \n",
    "                # Initialize the filtering widgets after successful load\n",
    "                initialize_filtering_widgets()\n",
    "            except Exception as e:\n",
    "                print(f\"Error loading CSV: {e}\")\n",
    "    \n",
    "    # Attach the click handler\n",
    "    load_button.on_click(on_load_button_click)\n",
    "    \n",
    "    # Display the widgets\n",
    "    display(widgets.VBox([\n",
    "        widgets.HTML(\"<h3>Step 1: Load Data</h3>\"),\n",
    "        csv_path_input,\n",
    "        output_path_input,\n",
    "        load_button,\n",
    "        load_output\n",
    "    ]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "43b29fed-1b12-46f8-a693-e00b4bdc7222",
   "metadata": {},
   "outputs": [],
   "source": [
    "def initialize_filtering_widgets():\n",
    "    \"\"\"Initialize widgets for filtering clinical notes\"\"\"\n",
    "    global filtered_mrn\n",
    "    filtered_mrn = None\n",
    "    \n",
    "    # Step 1: MRN Search\n",
    "    mrn_search = widgets.Text(\n",
    "        value='',\n",
    "        placeholder='Enter MRN',\n",
    "        description='MRN:',\n",
    "        disabled=False\n",
    "    )\n",
    "    mrn_search_button = widgets.Button(description='Search MRN')\n",
    "    \n",
    "    # Step 2: Encounter Type Filter\n",
    "    encounter_type_dropdown = widgets.Dropdown(\n",
    "        description='Encounter Type:',\n",
    "        disabled=True\n",
    "    )\n",
    "    encounter_type_button = widgets.Button(\n",
    "        description='Filter Encounter Type', \n",
    "        disabled=True\n",
    "    )\n",
    "    \n",
    "    # Step 3: Event Description Filter\n",
    "    event_desc_dropdown = widgets.Dropdown(\n",
    "        description='Event Description:',\n",
    "        disabled=True\n",
    "    )\n",
    "    event_desc_button = widgets.Button(\n",
    "        description='Filter Event Description', \n",
    "        disabled=True\n",
    "    )\n",
    "    \n",
    "    # Step 4: Process with hpomapper Button\n",
    "    process_button = widgets.Button(\n",
    "        description='Process with hpomapper',\n",
    "        button_style='success',\n",
    "        disabled=True\n",
    "    )\n",
    "    \n",
    "    # Output widget\n",
    "    output = widgets.Output()\n",
    "    \n",
    "    # Define the filtering functions\n",
    "    def search_mrn(b):\n",
    "        global mrn_filtered_df, filtered_mrn\n",
    "        with output:\n",
    "            clear_output()\n",
    "            mrn = mrn_search.value\n",
    "            if mrn:\n",
    "                mrn_filtered_df = df[df['MRN'].str.contains(mrn, case=False, na=False)]\n",
    "                if len(mrn_filtered_df) > 0:\n",
    "                    filtered_mrn = mrn\n",
    "                    print(f\"Found {len(mrn_filtered_df)} records for MRN containing '{mrn}'\")\n",
    "                    \n",
    "                    # Update encounter type dropdown\n",
    "                    encounter_type_dropdown.options = ['All'] + sorted(mrn_filtered_df['encounter_type'].unique().tolist())\n",
    "                    encounter_type_dropdown.disabled = False\n",
    "                    encounter_type_button.disabled = False\n",
    "                    \n",
    "                    display(mrn_filtered_df)\n",
    "                else:\n",
    "                    print(f\"No records found for MRN containing '{mrn}'\")\n",
    "            else:\n",
    "                print(\"Please enter an MRN\")\n",
    "\n",
    "    def filter_encounter_type(b):\n",
    "        global encounter_filtered_df\n",
    "        with output:\n",
    "            clear_output()\n",
    "            encounter_type = encounter_type_dropdown.value\n",
    "            if encounter_type != 'All':\n",
    "                encounter_filtered_df = mrn_filtered_df[mrn_filtered_df['encounter_type'] == encounter_type]\n",
    "            else:\n",
    "                encounter_filtered_df = mrn_filtered_df.copy()\n",
    "            \n",
    "            print(f\"Found {len(encounter_filtered_df)} records for encounter type '{encounter_type}'\")\n",
    "            \n",
    "            # Update event description dropdown\n",
    "            event_desc_dropdown.options = ['All'] + sorted(encounter_filtered_df['event_desc'].unique().tolist())\n",
    "            event_desc_dropdown.disabled = False\n",
    "            event_desc_button.disabled = False\n",
    "            \n",
    "            display(encounter_filtered_df)\n",
    "\n",
    "    def filter_event_desc(b):\n",
    "        global final_filtered_df, hpomapper_input_file\n",
    "        with output:\n",
    "            clear_output()\n",
    "            event_desc = event_desc_dropdown.value\n",
    "            if event_desc != 'All':\n",
    "                final_filtered_df = encounter_filtered_df[encounter_filtered_df['event_desc'] == event_desc]\n",
    "            else:\n",
    "                final_filtered_df = encounter_filtered_df.copy()\n",
    "            \n",
    "            print(f\"Found {len(final_filtered_df)} records for event description '{event_desc}'\")\n",
    "            \n",
    "            if len(final_filtered_df) > 0:\n",
    "                # Save the filtered DataFrame as a CSV for hpomapper\n",
    "                mrn_dir = save_blob_contents_and_prepare_hpo_input(final_filtered_df)\n",
    "                \n",
    "                # Set the hpomapper_input_file global variable\n",
    "                hpomapper_input_file = os.path.join(mrn_dir, \"notes_HPO.csv\")\n",
    "                \n",
    "                # Enable the hpomapper processing button\n",
    "                process_button.disabled = False\n",
    "                \n",
    "                print(f\"\\nReady to process notes for MRN: {filtered_mrn}\")\n",
    "                print(f\"Notes saved to: {mrn_dir}\")\n",
    "                print(f\"hpomapper input file prepared at: {hpomapper_input_file}\")\n",
    "                print(\"\\nClick 'Process with hpomapper' to continue\")\n",
    "            else:\n",
    "                process_button.disabled = True\n",
    "                print(\"No records found with the selected filters.\")\n",
    "            \n",
    "            display(final_filtered_df)\n",
    "    \n",
    "    def on_process_button_click(b):\n",
    "        with output:\n",
    "            clear_output()\n",
    "            if 'hpomapper_input_file' in globals() and os.path.exists(hpomapper_input_file):\n",
    "                print(f\"Processing notes with hpomapper...\")\n",
    "                print(f\"Input file: {hpomapper_input_file}\")\n",
    "                \n",
    "                # Run hpomapper on the filtered notes\n",
    "                results = run_hpomapper(hpomapper_input_file)\n",
    "                \n",
    "                if results is not None:\n",
    "                    # Get the MRN directory path\n",
    "                    mrn_dir = os.path.dirname(hpomapper_input_file)\n",
    "                    \n",
    "                    # Save the results in the MRN directory\n",
    "                    results_file = os.path.join(mrn_dir, \"hpomapper_results.csv\")\n",
    "                    results.to_csv(results_file, index=False)\n",
    "                    print(f\"\\nResults saved to: {results_file}\")\n",
    "                    \n",
    "                    # Display some statistics\n",
    "                    print(f\"\\nExtracted {len(results)} HPO terms for MRN {filtered_mrn}\")\n",
    "                    print(f\"Unique HPO terms: {results['hpo_term'].nunique()}\")\n",
    "                    \n",
    "                    # Show the results\n",
    "                    display(results)\n",
    "            else:\n",
    "                print(\"No input file available. Please complete the filtering step first.\")\n",
    "                if 'hpomapper_input_file' in globals():\n",
    "                    print(f\"Expected file path: {hpomapper_input_file}\")\n",
    "                    if not os.path.exists(hpomapper_input_file):\n",
    "                        print(f\"File does not exist at this path.\")\n",
    "                    \n",
    "                    # Try to find the file manually in the notes directory\n",
    "                    if filtered_mrn is not None:\n",
    "                        possible_path = os.path.join(notes_dir, str(filtered_mrn), \"notes_HPO.csv\")\n",
    "                        if os.path.exists(possible_path):\n",
    "                            print(f\"However, found a valid input file at: {possible_path}\")\n",
    "                            print(\"Please try again using this file.\")\n",
    "                            hpomapper_input_file = possible_path\n",
    "    \n",
    "    # Attach button click handlers\n",
    "    mrn_search_button.on_click(search_mrn)\n",
    "    encounter_type_button.on_click(filter_encounter_type)\n",
    "    event_desc_button.on_click(filter_event_desc)\n",
    "    process_button.on_click(on_process_button_click)\n",
    "    \n",
    "    # Display widgets\n",
    "    display(widgets.VBox([\n",
    "        widgets.HTML(\"<h3>Step 2: Filter Notes</h3>\"),\n",
    "        widgets.HBox([mrn_search, mrn_search_button]),\n",
    "        widgets.HBox([encounter_type_dropdown, encounter_type_button]),\n",
    "        widgets.HBox([event_desc_dropdown, event_desc_button]),\n",
    "        process_button,\n",
    "        output\n",
    "    ]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "4c5aa39b-13c8-4f1a-b87d-cf2f60093c24",
   "metadata": {},
   "outputs": [],
   "source": [
    "def save_blob_contents_and_prepare_hpo_input(filtered_df):\n",
    "    \"\"\"\n",
    "    Save blob contents as text files and prepare HPO input CSV\n",
    "    This preserves all columns from the original DataFrame\n",
    "    \"\"\"\n",
    "    saved_count = 0\n",
    "    \n",
    "    # Get the MRN from the first row (assuming all rows have the same MRN after filtering)\n",
    "    if len(filtered_df) > 0:\n",
    "        mrn = filtered_df['MRN'].iloc[0]\n",
    "        \n",
    "        # Create directory for this MRN in the notes folder\n",
    "        mrn_dir = os.path.join(notes_dir, str(mrn))\n",
    "        os.makedirs(mrn_dir, exist_ok=True)\n",
    "        \n",
    "        # Save text files\n",
    "        for _, row in filtered_df.iterrows():\n",
    "            # Clean up any characters that might be problematic in filenames\n",
    "            encounter_type = str(row['encounter_type']).replace('/', '_').replace('\\\\', '_').replace(' ', '_')\n",
    "            med_service = str(row.get('med_service', 'unknown')).replace('/', '_').replace('\\\\', '_').replace(' ', '_')\n",
    "            \n",
    "            # Create a structured text file with all required fields\n",
    "            structured_filename = f\"{row['MRN']}_{encounter_type}_{med_service}_{row['note_index']}.txt\"\n",
    "            structured_filepath = os.path.join(mrn_dir, structured_filename)\n",
    "            \n",
    "            with open(structured_filepath, 'w') as f:\n",
    "                # Write metadata\n",
    "                f.write(f\"ICD: {row.get('ICD', 'N/A')}\\n\")\n",
    "                f.write(f\"Encounter Type: {row.get('encounter_type', 'N/A')}\\n\")\n",
    "                f.write(f\"Medical Service: {row.get('med_service', 'N/A')}\\n\")\n",
    "                f.write(f\"Reason for Visit: {row.get('reason_for_visit', 'N/A')}\\n\")\n",
    "                f.write(f\"Encounter ID: {row.get('encntr_id', 'N/A')}\\n\")\n",
    "                f.write(f\"Event Description: {row.get('event_desc', 'N/A')}\\n\")\n",
    "                f.write(f\"Event End Datetime: {row.get('event_end_dt_tm', 'N/A')}\\n\")\n",
    "                f.write(f\"MRN: {row['MRN']}\\n\")\n",
    "                f.write(f\"Note Index: {row['note_index']}\\n\\n\")\n",
    "                \n",
    "                # Write the clinical note content\n",
    "                f.write(\"CLINICAL NOTE\\n\")\n",
    "                f.write(\"=============\\n\\n\")\n",
    "                f.write(row['blob_content_clean'])\n",
    "            \n",
    "            saved_count += 1\n",
    "        \n",
    "        # Create hpomapper input CSV with all the original columns\n",
    "        # This preserves the full DataFrame structure but adds a unique_id column\n",
    "        # that combines patient_id and note_index\n",
    "        hpo_input_df = filtered_df.copy()\n",
    "        \n",
    "        # Create unique ID column as patient_id + note_index\n",
    "        hpo_input_df['unique_id'] = hpo_input_df['MRN'] + '_' + hpo_input_df['note_index'].astype(str)\n",
    "        \n",
    "        # Rename columns to match hpomapper expectations\n",
    "        hpo_input_df['patient_id'] = hpo_input_df['unique_id']\n",
    "        hpo_input_df['note'] = hpo_input_df['blob_content_clean']\n",
    "        \n",
    "        # Save to CSV file in the MRN directory\n",
    "        hpo_csv_path = os.path.join(mrn_dir, \"notes_HPO.csv\")\n",
    "        hpo_input_df.to_csv(hpo_csv_path, index=False)\n",
    "        \n",
    "        print(f\"Saved {saved_count} structured text files in {mrn_dir}\")\n",
    "        print(f\"Created hpomapper input file at {hpo_csv_path}\")\n",
    "        \n",
    "        return mrn_dir\n",
    "    else:\n",
    "        print(\"No records to save\")\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "754dd265-0c04-4d3b-8367-2fd23f0435e7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 3 - Functions for reading and combining clinical notes\n",
    "\n",
    "def read_text_file(file_path):\n",
    "    \"\"\"Read the content of a text file.\"\"\"\n",
    "    try:\n",
    "        with open(file_path, 'r', encoding='utf-8') as f:\n",
    "            return f.read()\n",
    "    except Exception as e:\n",
    "        print(f\"Error reading file {file_path}: {e}\")\n",
    "        return \"\"\n",
    "\n",
    "def get_clinical_notes(directory_path):\n",
    "    \"\"\"Get all text files in a directory.\"\"\"\n",
    "    path = Path(directory_path)\n",
    "    if not path.exists() or not path.is_dir():\n",
    "        raise ValueError(f\"Invalid directory path: {directory_path}\")\n",
    "        \n",
    "    files = {}\n",
    "    for file_path in path.glob(\"**/*.txt\"):  # Search recursively for all .txt files\n",
    "        files[file_path.name] = read_text_file(file_path)\n",
    "        \n",
    "    print(f\"Found {len(files)} text files\")\n",
    "    return files\n",
    "\n",
    "def combine_clinical_notes(clinical_notes):\n",
    "    \"\"\"Combine all clinical notes into a single text with file identifiers.\"\"\"\n",
    "    combined_text = \"\"\n",
    "    \n",
    "    for filename, content in clinical_notes.items():\n",
    "        if content.strip():  # Skip empty files\n",
    "            combined_text += f\"\\n\\n--- CLINICAL NOTE: {filename} ---\\n\\n\"\n",
    "            combined_text += content\n",
    "    \n",
    "    return combined_text.strip()\n",
    "\n",
    "def prepare_hpomapper_input(filtered_df):\n",
    "    \"\"\"Convert filtered notes to format expected by hpomapper\"\"\"\n",
    "    global hpomapper_input_file\n",
    "    \n",
    "    # Create a new DataFrame in the format hpomapper expects\n",
    "    pheno_df = pd.DataFrame(columns=['patient_id', 'note'])\n",
    "    \n",
    "    # Group by MRN to process all notes for each patient\n",
    "    for mrn, group in filtered_df.groupby('MRN'):\n",
    "        # Combine all notes for this MRN into a single string\n",
    "        all_notes = \"\"\n",
    "        \n",
    "        for _, row in group.iterrows():\n",
    "            note_header = f\"\\n\\n--- {row.get('event_desc', 'Note')} ({row.get('encounter_type', 'Encounter')}) ---\\n\"\n",
    "            note_content = row['blob_content_clean']\n",
    "            all_notes += note_header + note_content\n",
    "        \n",
    "        # Add to the hpomapper input DataFrame\n",
    "        pheno_df = pheno_df.append({\n",
    "            'patient_id': mrn,\n",
    "            'note': all_notes.strip()\n",
    "        }, ignore_index=True)\n",
    "    \n",
    "    # Save to a temporary CSV file for hpomapper\n",
    "    hpomapper_input_file = os.path.join(notes_dir, 'hpomapper_input.csv')\n",
    "    pheno_df.to_csv(hpomapper_input_file, index=False)\n",
    "    \n",
    "    print(f\"Created hpomapper input file with notes for {len(pheno_df)} patients: {hpomapper_input_file}\")\n",
    "    print(\"Ready to run hpomapper on these notes.\")\n",
    "    \n",
    "    # Display a preview of the notes\n",
    "    for i, row in pheno_df.iterrows():\n",
    "        print(f\"\\nPatient ID: {row['patient_id']}\")\n",
    "        print(f\"Note preview: {row['note'][:200]}...\")\n",
    "        print(\"-\" * 80)\n",
    "    \n",
    "    return hpomapper_input_file"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "347ff839-f2ed-4576-be83-8c2a278c2fa3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 4 - Modified hpomapper Processing Function\n",
    "\n",
    "def run_hpomapper(input_file=None):\n",
    "    \"\"\"Process clinical notes with hpomapper\"\"\"\n",
    "    global hpo_embedding_file\n",
    "    \n",
    "    if input_file is None:\n",
    "        print(\"No input file specified. Please run data filtering first.\")\n",
    "        return None\n",
    "    \n",
    "    if not os.path.exists(input_file):\n",
    "        print(f\"Input file does not exist: {input_file}\")\n",
    "        return None\n",
    "    \n",
    "    print(f\"Processing clinical notes from {input_file}...\")\n",
    "    \n",
    "    try:\n",
    "        # Check if HPO embedding file exists\n",
    "        if not os.path.exists(hpo_embedding_file):\n",
    "            print(f\"HPO embedding file not found: {hpo_embedding_file}\")\n",
    "            print(\"Please run the HPO vectorization step first.\")\n",
    "            return None\n",
    "            \n",
    "        # Initialize components using the AWS helper\n",
    "        # Get a session using the helper (will handle credential issues)\n",
    "        aws_session = aws_helper.get_aws_session()\n",
    "        \n",
    "        # Initialize components - this is based on Cell 8 in the original notebook\n",
    "        llm_client = BedrockLLM(\n",
    "            model_id=\"anthropic.claude-v2\"\n",
    "            # No need to specify region or profile - helper will handle it\n",
    "        )\n",
    "        \n",
    "        # Initialize HPO vector database\n",
    "        hpo_db = HPOVectorDB(embedding_file=hpo_embedding_file)\n",
    "        \n",
    "        # Initialize hpomapper\n",
    "        hpomapper = hpomapper(\n",
    "            llm_client=llm_client,\n",
    "            hpo_db=hpo_db,\n",
    "            fuzzy_match_threshold=80  # Set the fuzzy matching threshold\n",
    "        )\n",
    "        \n",
    "        # Extract the MRN directory from the input file path\n",
    "        mrn_dir = os.path.dirname(input_file)\n",
    "        output_file = os.path.join(mrn_dir, \"hpomapper_results.csv\")\n",
    "        \n",
    "        # Process clinical notes - using the same approach as in the original notebook's Cell 8\n",
    "        print(\"Processing clinical notes...\")\n",
    "        \n",
    "        # Read input file which now contains all rows and columns from the filtered CSV\n",
    "        input_df = pd.read_csv(input_file)\n",
    "        \n",
    "        # Process the notes using the hpomapper process_clinical_notes method\n",
    "        # This function expects 'patient_id' and 'note' columns\n",
    "        # We're now using all rows, with unique_id as patient_id + note_index\n",
    "        # and blob_content_clean as the note text\n",
    "        results = hpomapper.process_clinical_notes(\n",
    "            notes_file=input_file,\n",
    "            output_file=output_file\n",
    "        )\n",
    "\n",
    "        print(f\"Extracted {len(results)} HPO terms\")\n",
    "        print(f\"Results saved to {output_file}\")\n",
    "        \n",
    "        # Additional analysis by patient\n",
    "        if len(results) > 0:\n",
    "            # Group by patient_id to show statistics per patient\n",
    "            patient_stats = results.groupby('patient_id').agg({\n",
    "                'hpo_id': 'count',\n",
    "                'match_score': ['mean', 'min', 'max']\n",
    "            })\n",
    "            \n",
    "            print(\"\\nHPO term extraction summary by patient:\")\n",
    "            display(patient_stats)\n",
    "            \n",
    "            # Show most common HPO terms for each patient\n",
    "            print(\"\\nMost common HPO terms by patient:\")\n",
    "            for patient_id in results['patient_id'].unique():\n",
    "                patient_results = results[results['patient_id'] == patient_id]\n",
    "                top_terms = patient_results['hpo_term'].value_counts().head(5)\n",
    "                \n",
    "                print(f\"\\nPatient {patient_id} - Top 5 HPO terms:\")\n",
    "                for term, count in top_terms.items():\n",
    "                    print(f\"  - {term}: {count} occurrences\")\n",
    "        \n",
    "        return results\n",
    "    except Exception as e:\n",
    "        print(f\"Error processing clinical notes: {str(e)}\")\n",
    "        \n",
    "        # Try to load previous results if available\n",
    "        previous_results_file = os.path.join(os.path.dirname(input_file), \"hpomapper_results.csv\")\n",
    "        if os.path.exists(previous_results_file):\n",
    "            print(f\"Attempting to load previous results from {previous_results_file}\")\n",
    "            try:\n",
    "                results = pd.read_csv(previous_results_file)\n",
    "                print(f\"Loaded {len(results)} HPO terms from previous run\")\n",
    "                return results\n",
    "            except Exception as load_error:\n",
    "                print(f\"Error loading previous results: {str(load_error)}\")\n",
    "        \n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "636fa1dc-4aab-40c6-b950-29cf7659e5bc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 5 - Run hpomapper on filtered notes\n",
    "def run_hpomapper(input_file=None):\n",
    "    \"\"\"Process clinical notes with hpomapper\"\"\"\n",
    "    \n",
    "    if input_file is None and 'hpomapper_input_file' in globals():\n",
    "        input_file = hpomapper_input_file\n",
    "    elif input_file is None:\n",
    "        print(\"No input file specified. Please run data filtering first.\")\n",
    "        return\n",
    "    \n",
    "    print(f\"Processing clinical notes from {input_file}...\")\n",
    "    \n",
    "    # Initialize components using the AWS helper\n",
    "    # Get a session using the helper (will handle credential issues)\n",
    "    aws_session = aws_helper.get_aws_session()\n",
    "    \n",
    "    # Initialize components\n",
    "    llm_client = BedrockLLM(\n",
    "        model_id=\"anthropic.claude-v2\"\n",
    "        # No need to specify region or profile - helper will handle it\n",
    "    )\n",
    "    \n",
    "    # Initialize HPO vector database\n",
    "    hpo_db = HPOVectorDB(embedding_file=hpo_embedding_file)\n",
    "    \n",
    "    # Initialize hpomapper\n",
    "    hpomapper = hpomapper(\n",
    "        llm_client=llm_client,\n",
    "        hpo_db=hpo_db,\n",
    "        fuzzy_match_threshold=80  # Set the fuzzy matching threshold\n",
    "    )\n",
    "    \n",
    "    # Process clinical notes\n",
    "    try:\n",
    "        results = hpomapper.process_clinical_notes(\n",
    "            notes_file=input_file,\n",
    "            output_file='hpomapper_results.csv'\n",
    "        )\n",
    "\n",
    "        print(f\"Extracted {len(results)} HPO terms\")\n",
    "        display(results.head())\n",
    "        return results\n",
    "    except Exception as e:\n",
    "        print(f\"Error processing clinical notes: {str(e)}\")\n",
    "        print(\"Attempting to load previous results if available...\")\n",
    "        if os.path.exists('hpomapper_results.csv'):\n",
    "            results = pd.read_csv('hpomapper_results.csv')\n",
    "            print(f\"Loaded {len(results)} HPO terms from previous run\")\n",
    "            return results\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "e13e077d-8ffb-4412-998f-49ad72eb2f1e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "No results file found. Visualization functions are defined but not executed.\n"
     ]
    }
   ],
   "source": [
    "# Cell 6: Basic Analysis Visualization Functions\n",
    "# From original Cell 10\n",
    "\n",
    "def visualize_basic_hpo_stats(results):\n",
    "    \"\"\"\n",
    "    Create basic visualizations for HPO extraction results\n",
    "    \n",
    "    Args:\n",
    "        results: DataFrame with HPO extraction results\n",
    "    \"\"\"\n",
    "    if results.empty:\n",
    "        print(\"No results to visualize. Please run hpomapper first.\")\n",
    "        return\n",
    "        \n",
    "    # Overview of extracted terms per patient\n",
    "    patient_term_counts = results.groupby('patient_id').size().reset_index(name='hpo_term_count')\n",
    "    print(\"HPO terms per patient:\")\n",
    "    print(patient_term_counts)\n",
    "\n",
    "    # Visualize terms per patient\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    sns.barplot(x='patient_id', y='hpo_term_count', data=patient_term_counts)\n",
    "    plt.title('Number of HPO Terms Extracted per Patient')\n",
    "    plt.xlabel('Patient ID')\n",
    "    plt.ylabel('Number of HPO Terms')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "    # Visualize match scores\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    sns.histplot(results['match_score'], bins=20)\n",
    "    plt.title('Distribution of Match Scores')\n",
    "    plt.xlabel('Match Score')\n",
    "    plt.ylabel('Frequency')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "    # Show the top HPO terms extracted\n",
    "    top_terms = results['hpo_term'].value_counts().head(10).reset_index()\n",
    "    top_terms.columns = ['hpo_term', 'count']\n",
    "\n",
    "    plt.figure(figsize=(12, 6))\n",
    "    sns.barplot(y='hpo_term', x='count', data=top_terms)\n",
    "    plt.title('Top 10 HPO Terms Extracted')\n",
    "    plt.xlabel('Count')\n",
    "    plt.ylabel('HPO Term')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return patient_term_counts, top_terms\n",
    "\n",
    "# Load results if available, for testing\n",
    "if os.path.exists('hpomapper_results.csv'):\n",
    "    test_results = pd.read_csv('hpomapper_results.csv')\n",
    "    print(f\"Loaded {len(test_results)} HPO terms from previous run for testing\")\n",
    "else:\n",
    "    test_results = pd.DataFrame()\n",
    "    print(\"No results file found. Visualization functions are defined but not executed.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "3e4958e3-bdda-430e-97e7-206e607ece09",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 7: Heatmap Visualization Function - Modified to show only color intensities\n",
    "def visualize_hpo_heatmap(results):\n",
    "    \"\"\"\n",
    "    Create a heatmap visualization of patient-HPO term relationships\n",
    "    with only color intensities (no numeric annotations)\n",
    "    \n",
    "    Args:\n",
    "        results: DataFrame with HPO extraction results\n",
    "    \"\"\"\n",
    "    if results.empty:\n",
    "        print(\"No results to visualize. Please run hpomapper first.\")\n",
    "        return None\n",
    "        \n",
    "    try:\n",
    "        # Create a pivot table of match scores by patient and HPO term\n",
    "        pivot_df = results.pivot_table(\n",
    "            index='patient_id', \n",
    "            columns='hpo_term', \n",
    "            values='match_score',\n",
    "            aggfunc='mean'\n",
    "        ).fillna(0)\n",
    "        \n",
    "        # Limit to top terms if there are too many\n",
    "        if pivot_df.shape[1] > 15:\n",
    "            print(f\"Limiting heatmap to top 15 HPO terms (out of {pivot_df.shape[1]})...\")\n",
    "            top_terms = results['hpo_term'].value_counts().head(15).index.tolist()\n",
    "            pivot_df = pivot_df[top_terms]\n",
    "        \n",
    "        # Create a heatmap WITHOUT annotations (removed annot=True parameter)\n",
    "        plt.figure(figsize=(14, 8))\n",
    "        sns.heatmap(pivot_df, cmap='YlGnBu', linewidths=.5)\n",
    "        plt.title('HPO Term Match Scores by Patient')\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Add color bar explanation\n",
    "        print(\"Color intensity represents match score:\")\n",
    "        print(\"- Darker blue indicates higher match scores\")\n",
    "        print(\"- Lighter blue indicates lower match scores\")\n",
    "        \n",
    "        return pivot_df\n",
    "    except Exception as e:\n",
    "        print(f\"Error creating heatmap: {str(e)}\")\n",
    "        print(\"This might happen if there are too many terms or only one patient.\")\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "ff24e6a7-f0c3-46e6-879c-3ea39e74b0f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 8: Enhanced Network Graph Visualization Function \n",
    "def visualize_hpo_network(results, min_edge_weight=0.5, highlight_term=None):\n",
    "    \"\"\"\n",
    "    Create an interactive network visualization of clinical notes and HPO terms\n",
    "    \n",
    "    Args:\n",
    "        results: DataFrame with HPO extraction results\n",
    "        min_edge_weight: Minimum match score threshold for edges (0.0-1.0)\n",
    "        highlight_term: Specific HPO term to highlight (optional)\n",
    "    \"\"\"\n",
    "    if results.empty:\n",
    "        print(\"No network to visualize. Please run hpomapper first.\")\n",
    "        return None\n",
    "        \n",
    "    try:\n",
    "        import networkx as nx\n",
    "        import plotly.graph_objects as go\n",
    "        from ipywidgets import interact, FloatSlider, Dropdown\n",
    "        \n",
    "        # Create a network graph\n",
    "        G = nx.Graph()\n",
    "        \n",
    "        # Add note nodes (what was previously labeled as patient nodes)\n",
    "        for note_id in results['patient_id'].unique():\n",
    "            G.add_node(note_id, type='note')\n",
    "        \n",
    "        # Add HPO term nodes\n",
    "        for hpo_term in results['hpo_term'].unique():\n",
    "            G.add_node(hpo_term, type='hpo_term')\n",
    "        \n",
    "        # Add edges between notes and HPO terms\n",
    "        for _, row in results.iterrows():\n",
    "            G.add_edge(row['patient_id'], row['hpo_term'], weight=row['match_score'])\n",
    "        \n",
    "        # Function to create and display the network with given parameters\n",
    "        def update_network(min_weight=min_edge_weight, highlight=highlight_term):\n",
    "            # Define node positions using spring layout\n",
    "            pos = nx.spring_layout(G, seed=42, k=0.3)\n",
    "            \n",
    "            # Separate nodes by type\n",
    "            note_nodes = [node for node in G.nodes() if 'M' in str(node) or 'PT' in str(node)]\n",
    "            hpo_nodes = [node for node in G.nodes() if node not in note_nodes]\n",
    "            \n",
    "            # Extract MRNs for grouping notes by patient\n",
    "            def extract_mrn(note_id):\n",
    "                parts = str(note_id).split('_')\n",
    "                return parts[0] if len(parts) > 0 else note_id\n",
    "            \n",
    "            # Create consistent colors for MRNs\n",
    "            note_mrns = [extract_mrn(node) for node in note_nodes]\n",
    "            unique_mrns = list(set(note_mrns))\n",
    "            \n",
    "            # Generate colors using HSL for better distinction\n",
    "            mrn_colors = {}\n",
    "            for i, mrn in enumerate(unique_mrns):\n",
    "                hue = i / max(1, len(unique_mrns))\n",
    "                mrn_colors[mrn] = f'hsl({int(hue * 360)}, 70%, 60%)'\n",
    "            \n",
    "            # Filter edges based on weight threshold\n",
    "            filtered_edges = [(u, v) for u, v, d in G.edges(data=True) if d['weight'] >= min_weight]\n",
    "            \n",
    "            # Create edge traces\n",
    "            edge_x = []\n",
    "            edge_y = []\n",
    "            \n",
    "            for u, v in filtered_edges:\n",
    "                x0, y0 = pos[u]\n",
    "                x1, y1 = pos[v]\n",
    "                edge_x.extend([x0, x1, None])\n",
    "                edge_y.extend([y0, y1, None])\n",
    "            \n",
    "            edge_trace = go.Scatter(\n",
    "                x=edge_x, y=edge_y,\n",
    "                line=dict(width=0.7, color='#888'),\n",
    "                hoverinfo='none',\n",
    "                mode='lines',\n",
    "                name='Connections'\n",
    "            )\n",
    "            \n",
    "            # Prepare note nodes data\n",
    "            note_x = []\n",
    "            note_y = []\n",
    "            note_colors = []\n",
    "            note_sizes = []\n",
    "            note_texts = []\n",
    "            \n",
    "            # Identify connected notes\n",
    "            connected_notes = set([u for u, v in filtered_edges if u in note_nodes] + \n",
    "                                [v for u, v in filtered_edges if v in note_nodes])\n",
    "            \n",
    "            # Identify highlighted term's connections\n",
    "            highlighted_connections = set()\n",
    "            if highlight and highlight in G.nodes():\n",
    "                highlighted_connections = set([n for n in G.neighbors(highlight) \n",
    "                                          if G.get_edge_data(highlight, n)['weight'] >= min_weight])\n",
    "            \n",
    "            for node in note_nodes:\n",
    "                x, y = pos[node]\n",
    "                note_x.append(x)\n",
    "                note_y.append(y)\n",
    "                \n",
    "                # Color by MRN\n",
    "                mrn = extract_mrn(node)\n",
    "                color = mrn_colors.get(mrn, 'lightgray')\n",
    "                # Highlight if connected to highlighted term\n",
    "                if node in highlighted_connections:\n",
    "                    color = 'orange'  # Highlight color\n",
    "                note_colors.append(color)\n",
    "                \n",
    "                # Size based on number of connections\n",
    "                connections = [v for u, v in filtered_edges if u == node]\n",
    "                node_size = 15 + min(20, len(connections) * 2)\n",
    "                note_sizes.append(node_size)\n",
    "                \n",
    "                # Create hover text\n",
    "                if '_' in str(node):\n",
    "                    mrn, note_idx = str(node).split('_', 1)\n",
    "                    hover_text = f\"Note ID: {node}<br>MRN: {mrn}<br>Note Index: {note_idx}\"\n",
    "                else:\n",
    "                    hover_text = f\"Note ID: {node}\"\n",
    "                \n",
    "                hover_text += f\"<br>Connected HPO terms: {len(connections)}\"\n",
    "                note_texts.append(hover_text)\n",
    "            \n",
    "            # Create note node trace\n",
    "            note_trace = go.Scatter(\n",
    "                x=note_x, y=note_y,\n",
    "                mode='markers',\n",
    "                hoverinfo='text',\n",
    "                marker=dict(\n",
    "                    color=note_colors,\n",
    "                    size=note_sizes,\n",
    "                    line=dict(width=1, color='darkgray'),\n",
    "                    opacity=[1.0 if node in connected_notes else 0.4 for node in note_nodes]\n",
    "                ),\n",
    "                text=note_texts,\n",
    "                name='Clinical Notes'\n",
    "            )\n",
    "            \n",
    "            # Prepare HPO nodes data\n",
    "            hpo_x = []\n",
    "            hpo_y = []\n",
    "            hpo_colors = []\n",
    "            hpo_sizes = []\n",
    "            hpo_texts = []\n",
    "            \n",
    "            # Identify connected HPO terms\n",
    "            connected_hpo = set([u for u, v in filtered_edges if u in hpo_nodes] + \n",
    "                              [v for u, v in filtered_edges if v in hpo_nodes])\n",
    "            \n",
    "            for node in hpo_nodes:\n",
    "                x, y = pos[node]\n",
    "                hpo_x.append(x)\n",
    "                hpo_y.append(y)\n",
    "                \n",
    "                # Size based on number of connections\n",
    "                connections = [u for u, v in filtered_edges if v == node]\n",
    "                node_size = 10 + min(15, len(connections) * 1.5)\n",
    "                hpo_sizes.append(node_size)\n",
    "                \n",
    "                # Create hover text\n",
    "                hover_text = f\"HPO Term: {node}<br>Connected notes: {len(connections)}\"\n",
    "                hpo_texts.append(hover_text)\n",
    "                \n",
    "                # Color - highlight if this is the selected term\n",
    "                if node == highlight:\n",
    "                    hpo_colors.append('red')  # Highlighted node\n",
    "                else:\n",
    "                    hpo_colors.append('#66CD00')  # Default green\n",
    "            \n",
    "            # Create HPO node trace\n",
    "            hpo_trace = go.Scatter(\n",
    "                x=hpo_x, y=hpo_y,\n",
    "                mode='markers',\n",
    "                hoverinfo='text',\n",
    "                marker=dict(\n",
    "                    color=hpo_colors,\n",
    "                    size=hpo_sizes,\n",
    "                    symbol='diamond',\n",
    "                    line=dict(width=1, color='darkgreen'),\n",
    "                    opacity=[1.0 if node in connected_hpo else 0.4 for node in hpo_nodes]\n",
    "                ),\n",
    "                text=hpo_texts,\n",
    "                name='HPO Terms'\n",
    "            )\n",
    "            \n",
    "            # Create labels for notes\n",
    "            note_labels = go.Scatter(\n",
    "                x=note_x, y=note_y,\n",
    "                mode='text',\n",
    "                text=[str(node).split('_')[0] + '...' for node in note_nodes],  # Show MRN part\n",
    "                textposition=\"top center\",\n",
    "                textfont=dict(\n",
    "                    family=\"Arial\",\n",
    "                    size=8,\n",
    "                    color=\"darkblue\"\n",
    "                ),\n",
    "                hoverinfo='none',\n",
    "                showlegend=False\n",
    "            )\n",
    "            \n",
    "            # Create labels for HPO terms\n",
    "            hpo_labels = go.Scatter(\n",
    "                x=hpo_x, y=hpo_y,\n",
    "                mode='text',\n",
    "                text=[str(node)[:15] + '...' if len(str(node)) > 15 else str(node) for node in hpo_nodes],\n",
    "                textposition=\"top center\",\n",
    "                textfont=dict(\n",
    "                    family=\"Arial\",\n",
    "                    size=7,\n",
    "                    color=\"darkgreen\"\n",
    "                ),\n",
    "                hoverinfo='none',\n",
    "                showlegend=False\n",
    "            )\n",
    "            \n",
    "            # Highlight edges if term is highlighted\n",
    "            highlight_edge_trace = None\n",
    "            if highlight and highlight in G.nodes():\n",
    "                highlight_edge_x = []\n",
    "                highlight_edge_y = []\n",
    "                \n",
    "                for neighbor in highlighted_connections:\n",
    "                    if G.has_edge(highlight, neighbor):\n",
    "                        x0, y0 = pos[highlight]\n",
    "                        x1, y1 = pos[neighbor]\n",
    "                        highlight_edge_x.extend([x0, x1, None])\n",
    "                        highlight_edge_y.extend([y0, y1, None])\n",
    "                \n",
    "                highlight_edge_trace = go.Scatter(\n",
    "                    x=highlight_edge_x, y=highlight_edge_y,\n",
    "                    line=dict(width=2, color='orange'),\n",
    "                    hoverinfo='none',\n",
    "                    mode='lines',\n",
    "                    name='Highlighted Connections'\n",
    "                )\n",
    "            \n",
    "            # Combine all traces\n",
    "            traces = [edge_trace, note_trace, hpo_trace, note_labels, hpo_labels]\n",
    "            if highlight_edge_trace:\n",
    "                traces.append(highlight_edge_trace)\n",
    "            \n",
    "            # Create figure\n",
    "            fig = go.Figure(data=traces)\n",
    "            \n",
    "            # Count connected nodes\n",
    "            connected_note_count = len(set([u for u, v in filtered_edges if u in note_nodes] + \n",
    "                                          [v for u, v in filtered_edges if v in note_nodes]))\n",
    "            connected_hpo_count = len(set([u for u, v in filtered_edges if u in hpo_nodes] + \n",
    "                                         [v for u, v in filtered_edges if v in hpo_nodes]))\n",
    "            \n",
    "            # Title text with highlight information if applicable\n",
    "            title_text = f\"Network of Clinical Notes and HPO Terms (min score: {min_weight:.1f})\"\n",
    "            if highlight:\n",
    "                title_text += f\" - Highlighting: {highlight}\"\n",
    "            \n",
    "            # Update layout\n",
    "            fig.update_layout(\n",
    "                title=dict(\n",
    "                    text=title_text,\n",
    "                    font=dict(size=16)\n",
    "                ),\n",
    "                showlegend=True,\n",
    "                hovermode='closest',\n",
    "                margin=dict(b=20, l=5, r=5, t=40),\n",
    "                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "                height=600,\n",
    "                width=800,\n",
    "                plot_bgcolor='white',\n",
    "                legend=dict(\n",
    "                    yanchor=\"top\",\n",
    "                    y=0.99,\n",
    "                    xanchor=\"right\",\n",
    "                    x=0.99,\n",
    "                    bgcolor=\"rgba(255, 255, 255, 0.8)\"\n",
    "                )\n",
    "            )\n",
    "            \n",
    "            # Add annotations for network statistics\n",
    "            fig.add_annotation(\n",
    "                xref=\"paper\", yref=\"paper\",\n",
    "                x=0.01, y=0.01,\n",
    "                text=(f\"Notes: {len(note_nodes)} | HPO Terms: {len(hpo_nodes)} | \" \n",
    "                      f\"Connected: {connected_note_count + connected_hpo_count} | \"\n",
    "                      f\"Edges: {len(filtered_edges)}\"),\n",
    "                showarrow=False,\n",
    "                font=dict(size=12),\n",
    "                bgcolor=\"rgba(255, 255, 255, 0.8)\",\n",
    "                bordercolor=\"black\",\n",
    "                borderwidth=1,\n",
    "                borderpad=4\n",
    "            )\n",
    "            \n",
    "            # Show the figure\n",
    "            fig.show()\n",
    "        \n",
    "        # Create interactive controls\n",
    "        # Get list of HPO terms for dropdown\n",
    "        hpo_term_list = sorted(list(set(results['hpo_term'])))\n",
    "        hpo_term_options = [None] + hpo_term_list  # Add None as first option\n",
    "        \n",
    "        # Create interactive widgets\n",
    "        print(\"Adjust the visualization parameters:\")\n",
    "        interact(\n",
    "            update_network, \n",
    "            min_weight=FloatSlider(\n",
    "                value=min_edge_weight, \n",
    "                min=0.0, \n",
    "                max=1.0, \n",
    "                step=0.1, \n",
    "                description='Min Edge Weight:',\n",
    "                continuous_update=False\n",
    "            ),\n",
    "            highlight=Dropdown(\n",
    "                options=hpo_term_options,\n",
    "                value=highlight_term,\n",
    "                description='Highlight HPO Term:',\n",
    "                style={'description_width': 'initial'},\n",
    "                layout={'width': 'max-content'}\n",
    "            )\n",
    "        )\n",
    "        \n",
    "        # Add usage instructions\n",
    "        print(\"\\nNetwork visualization features:\")\n",
    "        print(\"- Adjust 'Min Edge Weight' to filter connections by match score\")\n",
    "        print(\"- Select an HPO term from 'Highlight HPO Term' to focus on a specific term\")\n",
    "        print(\"- Hover over nodes to see details\")\n",
    "        print(\"- Zoom in/out with mouse wheel\")\n",
    "        print(\"- Pan by clicking and dragging\")\n",
    "        print(\"- Toggle visibility using the legend\")\n",
    "        print(\"\\nNode and edge colors:\")\n",
    "        print(\"- Green diamonds: HPO terms\")\n",
    "        print(\"- Colored circles: Clinical notes (grouped by MRN)\")\n",
    "        print(\"- Red diamond: Highlighted HPO term\")\n",
    "        print(\"- Orange circles: Notes connected to the highlighted HPO term\")\n",
    "        print(\"- Orange lines: Connections to the highlighted HPO term\")\n",
    "        \n",
    "        return G\n",
    "    except ImportError as ie:\n",
    "        print(f\"Required library not available: {str(ie)}\")\n",
    "        print(\"To enable network visualization, please install networkx and plotly.\")\n",
    "        return None\n",
    "    except Exception as e:\n",
    "        print(f\"Error creating network visualization: {str(e)}\")\n",
    "        import traceback\n",
    "        traceback.print_exc()\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "09244a74-7ee7-42d3-a17d-732ef29e9db1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "e781e123b2114286ad8b2dc9d00d6e9b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HTML(value='<h1>hpomapper: Extracting HPO Terms from Clinical Notes</h1>')"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "c7d19e114e5e4602925b17edf67973a0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HTML(value='<p>This notebook demonstrates the full workflow of hpomapper for extracting Human Phenotype Ontolo…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "02db518203c64f59aae66dd03c22e278",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Tab(children=(VBox(children=(HTML(value='<h2>Data Loading</h2>'), HTML(value='<p>Load clinical notes from CSV …"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Cell 9: Modified Initialize Pipeline Function with visualization support\n",
    "from IPython.display import display, HTML, clear_output\n",
    "import ipywidgets as widgets\n",
    "\n",
    "def initialize_pipeline():\n",
    "    \"\"\"Initialize the complete hpomapper pipeline with UI controls\"\"\"\n",
    "    global hpo_embedding_file\n",
    "    \n",
    "    # Create tab structure for the pipeline\n",
    "    tab = widgets.Tab()\n",
    "    \n",
    "    # Create tabs for each step of the pipeline\n",
    "    data_tab = widgets.VBox()\n",
    "    filter_tab = widgets.VBox()\n",
    "    hpomapper_tab = widgets.VBox()\n",
    "    analysis_tab = widgets.VBox()\n",
    "    \n",
    "    # Create the tab widget with all tabs\n",
    "    tab.children = [data_tab, filter_tab, hpomapper_tab, analysis_tab]\n",
    "    \n",
    "    # Set tab titles\n",
    "    tab.set_title(0, \"1. Data Loading\")\n",
    "    tab.set_title(1, \"2. Note Filtering\")\n",
    "    tab.set_title(2, \"3. Run hpomapper\")\n",
    "    tab.set_title(3, \"4. Analysis & Visualization\")\n",
    "    \n",
    "    # Output areas for each tab\n",
    "    data_output = widgets.Output()\n",
    "    filter_output = widgets.Output()\n",
    "    hpomapper_output = widgets.Output()\n",
    "    analysis_output = widgets.Output()\n",
    "    \n",
    "    # Tab 1: Data Loading\n",
    "    with data_output:\n",
    "        initialize_extraction()\n",
    "    \n",
    "    data_tab.children = [\n",
    "        widgets.HTML(\"<h2>Data Loading</h2>\"),\n",
    "        widgets.HTML(\"<p>Load clinical notes from CSV file.</p>\"),\n",
    "        data_output\n",
    "    ]\n",
    "    \n",
    "    # Tab 2: Note Filtering \n",
    "    filter_button = widgets.Button(\n",
    "        description='Initialize Filtering',\n",
    "        button_style='primary'\n",
    "    )\n",
    "    \n",
    "    def on_filter_button_click(b):\n",
    "        with filter_output:\n",
    "            clear_output()\n",
    "            initialize_filtering_widgets()\n",
    "    \n",
    "    filter_button.on_click(on_filter_button_click)\n",
    "    \n",
    "    filter_tab.children = [\n",
    "        widgets.HTML(\"<h2>Note Filtering</h2>\"),\n",
    "        widgets.HTML(\"<p>Filter clinical notes by MRN, encounter type, and event description.</p>\"),\n",
    "        filter_button,\n",
    "        filter_output\n",
    "    ]\n",
    "    \n",
    "    # Tab 3: Run hpomapper\n",
    "    # Add a field for HPO embedding file path\n",
    "    hpo_file_input = widgets.Text(\n",
    "        value=hpo_embedding_file,\n",
    "        placeholder='Path to HPO embedding file',\n",
    "        description='HPO Embeddings:',\n",
    "        layout={'width': '80%'},\n",
    "        style={'description_width': 'initial'}\n",
    "    )\n",
    "    \n",
    "    def on_hpo_file_change(change):\n",
    "        global hpo_embedding_file\n",
    "        hpo_embedding_file = change['new']\n",
    "        print(f\"HPO embedding file set to: {hpo_embedding_file}\")\n",
    "    \n",
    "    hpo_file_input.observe(on_hpo_file_change, names='value')\n",
    "    \n",
    "    run_button = widgets.Button(\n",
    "        description='Run hpomapper',\n",
    "        button_style='success'\n",
    "    )\n",
    "    \n",
    "    def on_run_button_click(b):\n",
    "        global hpomapper_input_file\n",
    "        with hpomapper_output:\n",
    "            clear_output()\n",
    "            \n",
    "            # Check if we have a valid hpomapper_input_file\n",
    "            if 'hpomapper_input_file' in globals() and hpomapper_input_file and os.path.exists(hpomapper_input_file):\n",
    "                print(f\"Processing notes with hpomapper...\")\n",
    "                print(f\"Input file: {hpomapper_input_file}\")\n",
    "                print(f\"Using HPO embeddings file: {hpo_embedding_file}\")\n",
    "                \n",
    "                # Run hpomapper\n",
    "                results = run_hpomapper(hpomapper_input_file)\n",
    "                if results is not None:\n",
    "                    display(results.head(10))\n",
    "                    \n",
    "            # Try to find the input file if it's not set\n",
    "            elif 'filtered_mrn' in globals() and filtered_mrn is not None:\n",
    "                possible_path = os.path.join(notes_dir, str(filtered_mrn), \"notes_HPO.csv\")\n",
    "                if os.path.exists(possible_path):\n",
    "                    print(f\"Found notes file at: {possible_path}\")\n",
    "                    hpomapper_input_file = possible_path\n",
    "                    print(f\"Using HPO embeddings file: {hpo_embedding_file}\")\n",
    "                    \n",
    "                    # Run hpomapper\n",
    "                    results = run_hpomapper(hpomapper_input_file)\n",
    "                    if results is not None:\n",
    "                        display(results.head(10))\n",
    "                else:\n",
    "                    print(f\"No input file found for MRN: {filtered_mrn}\")\n",
    "                    print(\"Please complete the filtering step first.\")\n",
    "            else:\n",
    "                print(\"No input file available. Please complete the filtering step first.\")\n",
    "    \n",
    "    run_button.on_click(on_run_button_click)\n",
    "    \n",
    "    hpomapper_tab.children = [\n",
    "        widgets.HTML(\"<h2>Run hpomapper</h2>\"),\n",
    "        widgets.HTML(\"<p>Extract HPO terms from filtered clinical notes.</p>\"),\n",
    "        hpo_file_input,\n",
    "        run_button,\n",
    "        hpomapper_output\n",
    "    ]\n",
    "    \n",
    "    # Tab 4: Analysis & Visualization - FIXED VERSION\n",
    "    # Create a button to generate visualizations explicitly\n",
    "    generate_viz_button = widgets.Button(\n",
    "        description='Generate Visualizations',\n",
    "        button_style='info',\n",
    "        icon='chart-bar'\n",
    "    )\n",
    "    \n",
    "    def on_generate_viz_button_click(b):\n",
    "        \"\"\"Handle the visualization generation button click\"\"\"\n",
    "        with analysis_output:\n",
    "            clear_output()\n",
    "            print(\"Generating visualizations, please wait...\")\n",
    "            \n",
    "            # Find results file\n",
    "            results_file = None\n",
    "            if 'filtered_mrn' in globals() and filtered_mrn is not None:\n",
    "                possible_results = os.path.join(notes_dir, str(filtered_mrn), \"hpomapper_results.csv\")\n",
    "                if os.path.exists(possible_results):\n",
    "                    results_file = possible_results\n",
    "            \n",
    "            # Fall back to default results file\n",
    "            if results_file is None and os.path.exists('hpomapper_results.csv'):\n",
    "                results_file = 'hpomapper_results.csv'\n",
    "            \n",
    "            if results_file and os.path.exists(results_file):\n",
    "                try:\n",
    "                    # Load results\n",
    "                    results = pd.read_csv(results_file)\n",
    "                    \n",
    "                    # Clear previous output and show status\n",
    "                    clear_output(wait=True)\n",
    "                    print(f\"Loaded {len(results)} HPO terms from {results_file}\")\n",
    "                    print(\"Generating visualizations...\")\n",
    "                    \n",
    "                    # Create basic statistics table\n",
    "                    print(\"\\n=== BASIC STATISTICS ===\")\n",
    "                    print(f\"Number of unique patients: {results['patient_id'].nunique()}\")\n",
    "                    print(f\"Number of unique HPO terms: {results['hpo_term'].nunique()}\")\n",
    "                    print(f\"Average match score: {results['match_score'].mean():.2f}\")\n",
    "                    print(f\"Min match score: {results['match_score'].min():.2f}\")\n",
    "                    print(f\"Max match score: {results['match_score'].max():.2f}\")\n",
    "                    \n",
    "                    # Generate visualizations directly\n",
    "                    print(\"\\n=== BASIC VISUALIZATIONS ===\")\n",
    "                    print(\"Patient term counts, match distribution, and top terms:\")\n",
    "                    visualize_basic_hpo_stats(results)\n",
    "                    \n",
    "                    print(\"\\n=== HEATMAP VISUALIZATION ===\")\n",
    "                    visualize_hpo_heatmap(results)\n",
    "                    \n",
    "                    print(\"\\n=== NETWORK VISUALIZATION ===\")\n",
    "                    visualize_hpo_network(results)\n",
    "                    \n",
    "                    # Show full results table\n",
    "                    print(\"\\n=== FULL RESULTS TABLE ===\")\n",
    "                    display(results)\n",
    "                    \n",
    "                except Exception as e:\n",
    "                    clear_output(wait=True)\n",
    "                    print(f\"Error generating visualizations: {str(e)}\")\n",
    "                    import traceback\n",
    "                    traceback.print_exc()\n",
    "            else:\n",
    "                clear_output(wait=True)\n",
    "                print(\"No results file found. Please run hpomapper first.\")\n",
    "                if 'filtered_mrn' in globals() and filtered_mrn is not None:\n",
    "                    print(f\"Expected file path: {os.path.join(notes_dir, str(filtered_mrn), 'hpomapper_results.csv')}\")\n",
    "                else:\n",
    "                    print(\"Expected file path: hpomapper_results.csv\")\n",
    "    \n",
    "    generate_viz_button.on_click(on_generate_viz_button_click)\n",
    "    \n",
    "    # Create a button to refresh results\n",
    "    refresh_button = widgets.Button(\n",
    "        description='Refresh Results',\n",
    "        button_style='primary',\n",
    "        icon='refresh',\n",
    "        disabled=False\n",
    "    )\n",
    "    \n",
    "    def on_refresh_button_click(b):\n",
    "        \"\"\"Handle the refresh button click\"\"\"\n",
    "        with analysis_output:\n",
    "            clear_output()\n",
    "            print(\"Checking for new results...\")\n",
    "            \n",
    "            # Find results file\n",
    "            results_file = None\n",
    "            if 'filtered_mrn' in globals() and filtered_mrn is not None:\n",
    "                possible_results = os.path.join(notes_dir, str(filtered_mrn), \"hpomapper_results.csv\")\n",
    "                if os.path.exists(possible_results):\n",
    "                    results_file = possible_results\n",
    "                    print(f\"Found results for MRN {filtered_mrn}: {possible_results}\")\n",
    "            \n",
    "            # Fall back to default results file\n",
    "            if results_file is None and os.path.exists('hpomapper_results.csv'):\n",
    "                results_file = 'hpomapper_results.csv'\n",
    "                print(f\"Found default results file: {results_file}\")\n",
    "            \n",
    "            if results_file and os.path.exists(results_file):\n",
    "                try:\n",
    "                    # Just load and show basic info\n",
    "                    results = pd.read_csv(results_file)\n",
    "                    print(f\"\\nLoaded {len(results)} HPO terms from {results_file}\")\n",
    "                    print(f\"Number of unique patients: {results['patient_id'].nunique()}\")\n",
    "                    print(f\"Number of unique HPO terms: {results['hpo_term'].nunique()}\")\n",
    "                    print(\"\\nClick 'Generate Visualizations' to view full analysis and visualizations.\")\n",
    "                except Exception as e:\n",
    "                    print(f\"Error loading results: {str(e)}\")\n",
    "            else:\n",
    "                print(\"No results file found. Please run hpomapper first.\")\n",
    "    \n",
    "    refresh_button.on_click(on_refresh_button_click)\n",
    "    \n",
    "    # Modified tab selection handler - just shows a prompt rather than auto-loading\n",
    "    def on_tab_selected(change):\n",
    "        if change['new'] == 3:  # Index 3 is the analysis tab\n",
    "            with analysis_output:\n",
    "                clear_output(wait=True)\n",
    "                print(\"Welcome to the Analysis & Visualization tab!\")\n",
    "                print(\"\\nClick 'Refresh Results' to check for available results\")\n",
    "                print(\"Click 'Generate Visualizations' to create all visualizations\")\n",
    "    \n",
    "    # Connect the tab selection event\n",
    "    tab.observe(on_tab_selected, names='selected_index')\n",
    "    \n",
    "    # Create button layout\n",
    "    button_layout = widgets.HBox([refresh_button, generate_viz_button])\n",
    "    \n",
    "    analysis_tab.children = [\n",
    "        widgets.HTML(\"<h2>Analysis & Visualization</h2>\"),\n",
    "        widgets.HTML(\"<p>Visualize and analyze the HPO terms extracted from clinical notes.</p>\"),\n",
    "        button_layout,\n",
    "        analysis_output\n",
    "    ]\n",
    "    \n",
    "    # Display the complete tab interface\n",
    "    display(widgets.HTML(\"<h1>hpomapper: Extracting HPO Terms from Clinical Notes</h1>\"))\n",
    "    display(widgets.HTML(\"<p>This notebook demonstrates the full workflow of hpomapper for extracting Human Phenotype Ontology (HPO) terms from clinical notes.</p>\"))\n",
    "    display(tab)\n",
    "\n",
    "# Run the pipeline initialization\n",
    "initialize_pipeline()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aa043068-b017-4a2f-8f7b-2a855c5a0e25",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1815409c-caac-49f0-ad5b-7a7b5e355fef",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0bc3155b-716f-4b65-a194-dbbd9ae0acc0",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5a135325-36d0-4646-a09c-7b5f49cbcc58",
   "metadata": {},
   "outputs": [],
   "source": [
    "# New cell to add after cell 6 - Comprehensive visualization function\n",
    "def display_all_hpomapper_visualizations(results_file=None):\n",
    "    \"\"\"\n",
    "    Display all hpomapper visualizations in one function\n",
    "    \n",
    "    Args:\n",
    "        results_file: Path to hpomapper results CSV. If None, will try to find it automatically.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Find results file if not provided\n",
    "        if results_file is None:\n",
    "            if filtered_mrn is not None:\n",
    "                possible_results = os.path.join(notes_dir, str(filtered_mrn), \"hpomapper_results.csv\")\n",
    "                if os.path.exists(possible_results):\n",
    "                    results_file = possible_results\n",
    "            \n",
    "            # Fall back to default results file\n",
    "            if results_file is None and os.path.exists('hpomapper_results.csv'):\n",
    "                results_file = 'hpomapper_results.csv'\n",
    "        \n",
    "        if not results_file or not os.path.exists(results_file):\n",
    "            print(\"No results file found. Please run hpomapper first.\")\n",
    "            return\n",
    "            \n",
    "        print(f\"Loading results from: {results_file}\")\n",
    "        results = pd.read_csv(results_file)\n",
    "        \n",
    "        print(\"\\n\" + \"=\"*80)\n",
    "        print(\"hpomapper VISUALIZATION SUMMARY\")\n",
    "        print(\"=\"*80)\n",
    "        \n",
    "        # Section 1: Basic Statistics\n",
    "        print(\"\\n1. BASIC STATISTICS\")\n",
    "        print(\"-\"*50)\n",
    "        print(f\"Total HPO terms extracted: {len(results)}\")\n",
    "        print(f\"Number of unique patients: {results['patient_id'].nunique()}\")\n",
    "        print(f\"Number of unique HPO terms: {results['hpo_term'].nunique()}\")\n",
    "        print(f\"Average match score: {results['match_score'].mean():.2f}\")\n",
    "        print(f\"Min match score: {results['match_score'].min():.2f}\")\n",
    "        print(f\"Max match score: {results['match_score'].max():.2f}\")\n",
    "        \n",
    "        # Section 2: Patient Statistics\n",
    "        patient_term_counts = results.groupby('patient_id').size().reset_index(name='hpo_term_count')\n",
    "        \n",
    "        print(\"\\n2. HPO TERMS PER PATIENT\")\n",
    "        print(\"-\"*50)\n",
    "        for _, row in patient_term_counts.iterrows():\n",
    "            print(f\"Patient {row['patient_id']}: {row['hpo_term_count']} terms\")\n",
    "        \n",
    "        # Visualization 1: HPO Terms per Patient\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        sns.barplot(x='patient_id', y='hpo_term_count', data=patient_term_counts)\n",
    "        plt.title('Number of HPO Terms Extracted per Patient')\n",
    "        plt.xlabel('Patient ID')\n",
    "        plt.ylabel('Number of HPO Terms')\n",
    "        plt.xticks(rotation=45)\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Visualization 2: Match Score Distribution\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        sns.histplot(results['match_score'], bins=20)\n",
    "        plt.title('Distribution of Match Scores')\n",
    "        plt.xlabel('Match Score')\n",
    "        plt.ylabel('Frequency')\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Section 3: Top HPO Terms\n",
    "        print(\"\\n3. TOP HPO TERMS\")\n",
    "        print(\"-\"*50)\n",
    "        top_terms = results['hpo_term'].value_counts().head(10)\n",
    "        for term, count in top_terms.items():\n",
    "            print(f\"{term}: {count} occurrences\")\n",
    "        \n",
    "        # Visualization 3: Top HPO Terms\n",
    "        top_terms_df = top_terms.reset_index()\n",
    "        top_terms_df.columns = ['hpo_term', 'count']\n",
    "        \n",
    "        plt.figure(figsize=(12, 6))\n",
    "        sns.barplot(y='hpo_term', x='count', data=top_terms_df)\n",
    "        plt.title('Top 10 HPO Terms Extracted')\n",
    "        plt.xlabel('Count')\n",
    "        plt.ylabel('HPO Term')\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Visualization 4: Heatmap of Patient-HPO Term Relationships\n",
    "        try:\n",
    "            print(\"\\n4. PATIENT-HPO TERM HEATMAP\")\n",
    "            print(\"-\"*50)\n",
    "            \n",
    "            # Create a pivot table for the heatmap\n",
    "            pivot_df = results.pivot_table(\n",
    "                index='patient_id', \n",
    "                columns='hpo_term', \n",
    "                values='match_score',\n",
    "                aggfunc='mean'\n",
    "            ).fillna(0)\n",
    "            \n",
    "            # Limit to top terms if there are too many\n",
    "            if pivot_df.shape[1] > 15:\n",
    "                print(f\"Limiting heatmap to top 15 HPO terms (out of {pivot_df.shape[1]})...\")\n",
    "                top_terms = results['hpo_term'].value_counts().head(15).index.tolist()\n",
    "                pivot_df = pivot_df[top_terms]\n",
    "            \n",
    "            # Create a heatmap\n",
    "            plt.figure(figsize=(14, 8))\n",
    "            sns.heatmap(pivot_df, annot=True, cmap='YlGnBu', fmt=\".2f\", linewidths=.5)\n",
    "            plt.title('HPO Term Match Scores by Patient')\n",
    "            plt.tight_layout()\n",
    "            plt.show()\n",
    "        except Exception as e:\n",
    "            print(f\"Error creating heatmap: {str(e)}\")\n",
    "            print(\"This might happen if there are too many terms or only one patient.\")\n",
    "        \n",
    "        # Visualization 5: Network Visualization\n",
    "        try:\n",
    "            print(\"\\n5. NETWORK VISUALIZATION\")\n",
    "            print(\"-\"*50)\n",
    "            \n",
    "            import networkx as nx\n",
    "            import plotly.graph_objects as go\n",
    "            \n",
    "            print(\"Creating network visualization...\")\n",
    "            \n",
    "            # Create a network graph\n",
    "            G = nx.Graph()\n",
    "            \n",
    "            # Add note nodes\n",
    "            for note_id in results['patient_id'].unique():\n",
    "                G.add_node(note_id, type='note')\n",
    "            \n",
    "            # Add HPO term nodes\n",
    "            for hpo_term in results['hpo_term'].unique():\n",
    "                G.add_node(hpo_term, type='hpo_term')\n",
    "            \n",
    "            # Add edges between notes and HPO terms\n",
    "            for _, row in results.iterrows():\n",
    "                G.add_edge(row['patient_id'], row['hpo_term'], weight=row['match_score'])\n",
    "            \n",
    "            print(f\"Network created with {len(G.nodes())} nodes and {len(G.edges())} edges\")\n",
    "            print(f\"Notes: {len([n for n in G.nodes() if 'M' in str(n) or 'PT' in str(n)])}\")\n",
    "            print(f\"HPO Terms: {len([n for n in G.nodes() if not ('M' in str(n) or 'PT' in str(n))])}\")\n",
    "            \n",
    "            # Define node positions using spring layout\n",
    "            pos = nx.spring_layout(G, seed=42, k=0.3)\n",
    "            \n",
    "            # Separate nodes by type\n",
    "            note_nodes = [node for node in G.nodes() if 'M' in str(node) or 'PT' in str(node)]\n",
    "            hpo_nodes = [node for node in G.nodes() if node not in note_nodes]\n",
    "            \n",
    "            # Create edge traces\n",
    "            edge_x = []\n",
    "            edge_y = []\n",
    "            \n",
    "            for u, v in G.edges():\n",
    "                x0, y0 = pos[u]\n",
    "                x1, y1 = pos[v]\n",
    "                edge_x.extend([x0, x1, None])\n",
    "                edge_y.extend([y0, y1, None])\n",
    "            \n",
    "            edge_trace = go.Scatter(\n",
    "                x=edge_x, y=edge_y,\n",
    "                line=dict(width=0.7, color='#888'),\n",
    "                hoverinfo='none',\n",
    "                mode='lines',\n",
    "                name='Connections'\n",
    "            )\n",
    "            \n",
    "            # Prepare note nodes data\n",
    "            note_x = [pos[node][0] for node in note_nodes]\n",
    "            note_y = [pos[node][1] for node in note_nodes]\n",
    "            note_texts = [f\"Note ID: {node}<br>Connected HPO terms: {len(list(G.neighbors(node)))}\" for node in note_nodes]\n",
    "            \n",
    "            note_trace = go.Scatter(\n",
    "                x=note_x, y=note_y,\n",
    "                mode='markers',\n",
    "                hoverinfo='text',\n",
    "                marker=dict(\n",
    "                    color='royalblue',\n",
    "                    size=15,\n",
    "                    line=dict(width=1, color='darkgray')\n",
    "                ),\n",
    "                text=note_texts,\n",
    "                name='Clinical Notes'\n",
    "            )\n",
    "            \n",
    "            # Prepare HPO nodes data\n",
    "            hpo_x = [pos[node][0] for node in hpo_nodes]\n",
    "            hpo_y = [pos[node][1] for node in hpo_nodes]\n",
    "            hpo_texts = [f\"HPO Term: {node}<br>Connected notes: {len(list(G.neighbors(node)))}\" for node in hpo_nodes]\n",
    "            \n",
    "            hpo_trace = go.Scatter(\n",
    "                x=hpo_x, y=hpo_y,\n",
    "                mode='markers',\n",
    "                hoverinfo='text',\n",
    "                marker=dict(\n",
    "                    color='#66CD00',\n",
    "                    size=10,\n",
    "                    symbol='diamond',\n",
    "                    line=dict(width=1, color='darkgreen')\n",
    "                ),\n",
    "                text=hpo_texts,\n",
    "                name='HPO Terms'\n",
    "            )\n",
    "            \n",
    "            # Create labels\n",
    "            note_labels = go.Scatter(\n",
    "                x=note_x, y=note_y,\n",
    "                mode='text',\n",
    "                text=[str(node).split('_')[0] + '...' for node in note_nodes],  # Show MRN part\n",
    "                textposition=\"top center\",\n",
    "                textfont=dict(\n",
    "                    family=\"Arial\",\n",
    "                    size=8,\n",
    "                    color=\"darkblue\"\n",
    "                ),\n",
    "                hoverinfo='none',\n",
    "                showlegend=False\n",
    "            )\n",
    "            \n",
    "            hpo_labels = go.Scatter(\n",
    "                x=hpo_x, y=hpo_y,\n",
    "                mode='text',\n",
    "                text=[str(node)[:15] + '...' if len(str(node)) > 15 else str(node) for node in hpo_nodes],\n",
    "                textposition=\"top center\",\n",
    "                textfont=dict(\n",
    "                    family=\"Arial\",\n",
    "                    size=7,\n",
    "                    color=\"darkgreen\"\n",
    "                ),\n",
    "                hoverinfo='none',\n",
    "                showlegend=False\n",
    "            )\n",
    "            \n",
    "            # Create figure with all traces\n",
    "            fig = go.Figure(data=[edge_trace, note_trace, hpo_trace, note_labels, hpo_labels])\n",
    "            \n",
    "            # Update layout\n",
    "            fig.update_layout(\n",
    "                title='Network of Clinical Notes and HPO Terms',\n",
    "                showlegend=True,\n",
    "                hovermode='closest',\n",
    "                margin=dict(b=20, l=5, r=5, t=40),\n",
    "                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "                height=600,\n",
    "                width=900,\n",
    "                plot_bgcolor='white',\n",
    "                legend=dict(\n",
    "                    yanchor=\"top\",\n",
    "                    y=0.99,\n",
    "                    xanchor=\"right\",\n",
    "                    x=0.99,\n",
    "                    bgcolor=\"rgba(255, 255, 255, 0.8)\"\n",
    "                )\n",
    "            )\n",
    "            \n",
    "            # Show the plot\n",
    "            fig.show()\n",
    "            \n",
    "            print(\"\\nNote: The network visualization above is interactive. You can:\")\n",
    "            print(\"- Hover over nodes to see details\")\n",
    "            print(\"- Zoom in/out with the mouse wheel\")\n",
    "            print(\"- Pan by clicking and dragging\")\n",
    "            print(\"- Toggle node visibility using the legend\")\n",
    "            \n",
    "        except ImportError as ie:\n",
    "            print(f\"Required library not available: {str(ie)}\")\n",
    "            print(\"To enable network visualization, please install networkx and plotly.\")\n",
    "        except Exception as e:\n",
    "            print(f\"Error creating network visualization: {str(e)}\")\n",
    "            import traceback\n",
    "            traceback.print_exc()\n",
    "            \n",
    "        # Section 6: Full Results Table\n",
    "        print(\"\\n6. FULL RESULTS TABLE\")\n",
    "        print(\"-\"*50)\n",
    "        display(results)\n",
    "            \n",
    "    except Exception as e:\n",
    "        print(f\"Error generating visualizations: {str(e)}\")\n",
    "        import traceback\n",
    "        traceback.print_exc()\n",
    "\n",
    "# Example usage:\n",
    "display_all_hpomapper_visualizations()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02b084ba-c233-4187-8ad8-320c57fe5496",
   "metadata": {},
   "outputs": [],
   "source": [
    "display_all_hpomapper_visualizations()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "47dc3ac2-dde2-429f-b356-86e0cd380cc5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 8 - Batch Processing Function for Multiple Patients\n",
    "\n",
    "def batch_process_mrns(csv_path, notes_dir, mrn_list):\n",
    "    \"\"\"\n",
    "    Process multiple MRNs in batch mode\n",
    "    \n",
    "    Args:\n",
    "        csv_path: Path to CSV file with clinical notes\n",
    "        notes_dir: Directory to save extracted notes\n",
    "        mrn_list: List of MRNs to process\n",
    "        \n",
    "    Returns:\n",
    "        Dictionary mapping MRNs to their results DataFrames\n",
    "    \"\"\"\n",
    "    results_dict = {}\n",
    "    \n",
    "    print(f\"Starting batch processing for {len(mrn_list)} MRNs...\")\n",
    "    \n",
    "    for i, mrn in enumerate(mrn_list):\n",
    "        print(f\"\\n\\n{'='*80}\")\n",
    "        print(f\"Processing MRN {i+1}/{len(mrn_list)}: {mrn}\")\n",
    "        print(f\"{'='*80}\\n\")\n",
    "        \n",
    "        # Process this MRN\n",
    "        mrn_output_dir = os.path.join(notes_dir, f\"mrn_{mrn}\")\n",
    "        results = run_complete_pipeline(\n",
    "            csv_path=csv_path,\n",
    "            notes_dir=mrn_output_dir,\n",
    "            mrn_filter=mrn\n",
    "        )\n",
    "        \n",
    "        # Store results\n",
    "        if results is not None and not results.empty:\n",
    "            results_dict[mrn] = results\n",
    "            \n",
    "            # Save to a dedicated CSV for this MRN\n",
    "            mrn_csv = os.path.join(mrn_output_dir, f\"hpomapper_results_{mrn}.csv\")\n",
    "            results.to_csv(mrn_csv, index=False)\n",
    "            print(f\"Saved results for MRN {mrn} to {mrn_csv}\")\n",
    "    \n",
    "    # Combine all results\n",
    "    if results_dict:\n",
    "        all_results = pd.concat(list(results_dict.values()), ignore_index=True)\n",
    "        combined_csv = os.path.join(notes_dir, \"hpomapper_results_all.csv\")\n",
    "        all_results.to_csv(combined_csv, index=False)\n",
    "        print(f\"\\nSaved combined results for all MRNs to {combined_csv}\")\n",
    "        \n",
    "        # Summary of processed MRNs\n",
    "        print(\"\\nSummary:\")\n",
    "        print(f\"Total MRNs processed: {len(results_dict)}\")\n",
    "        print(f\"Total HPO terms extracted: {len(all_results)}\")\n",
    "        \n",
    "        # Terms per MRN\n",
    "        terms_per_mrn = all_results.groupby('patient_id').size()\n",
    "        print(\"\\nHPO terms per MRN:\")\n",
    "        for mrn, count in terms_per_mrn.items():\n",
    "            print(f\"  {mrn}: {count} terms\")\n",
    "    \n",
    "    return results_dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "039d7226-80e7-494e-9b23-a7f3e5b3081b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 10 - Analyzing and visualizing the results\n",
    "# ## 4. Analyzing and visualizing the results\n",
    "# Let's analyze the extracted HPO terms and create some visualizations\n",
    "\n",
    "# Load results if we've already run hpomapper\n",
    "if os.path.exists('hpomapper_results.csv'):\n",
    "    results = pd.read_csv('hpomapper_results.csv')\n",
    "    print(f\"Loaded {len(results)} HPO terms from previous run\")\n",
    "else:\n",
    "    print(\"No results file found. Please run hpomapper successfully first.\")\n",
    "    # Create an empty DataFrame to avoid errors\n",
    "    results = pd.DataFrame(columns=['patient_id', 'clinical_phrase', 'hpo_id', 'hpo_term', 'match_score', 'definition'])\n",
    "\n",
    "if not results.empty:\n",
    "    # Overview of extracted terms per patient\n",
    "    patient_term_counts = results.groupby('patient_id').size().reset_index(name='hpo_term_count')\n",
    "    print(\"HPO terms per patient:\")\n",
    "    print(patient_term_counts)\n",
    "\n",
    "    # Visualize terms per patient\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    sns.barplot(x='patient_id', y='hpo_term_count', data=patient_term_counts)\n",
    "    plt.title('Number of HPO Terms Extracted per Patient')\n",
    "    plt.xlabel('Patient ID')\n",
    "    plt.ylabel('Number of HPO Terms')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "    # Visualize match scores\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    sns.histplot(results['match_score'], bins=20)\n",
    "    plt.title('Distribution of Match Scores')\n",
    "    plt.xlabel('Match Score')\n",
    "    plt.ylabel('Frequency')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "    # Show the top HPO terms extracted\n",
    "    top_terms = results['hpo_term'].value_counts().head(10).reset_index()\n",
    "    top_terms.columns = ['hpo_term', 'count']\n",
    "\n",
    "    plt.figure(figsize=(12, 6))\n",
    "    sns.barplot(y='hpo_term', x='count', data=top_terms)\n",
    "    plt.title('Top 10 HPO Terms Extracted')\n",
    "    plt.xlabel('Count')\n",
    "    plt.ylabel('HPO Term')\n",
    "    plt.tight_layout()\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "920a3927-ca38-4f6f-a93a-7a773325b8e9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 11 - Create a heatmap of match scores\n",
    "if not results.empty:\n",
    "    # Create a pivot table of match scores by patient and HPO term\n",
    "    pivot_df = results.pivot_table(\n",
    "        index='patient_id', \n",
    "        columns='hpo_term', \n",
    "        values='match_score',\n",
    "        aggfunc='mean'\n",
    "    ).fillna(0)\n",
    "    \n",
    "    # Create a heatmap\n",
    "    plt.figure(figsize=(14, 8))\n",
    "    sns.heatmap(pivot_df, annot=True, cmap='YlGnBu', fmt=\".2f\", linewidths=.5)\n",
    "    plt.title('HPO Term Match Scores by Patient')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Display the full results table\n",
    "    print(\"\\nFull results table:\")\n",
    "    display(results)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "375e276e-2b94-446b-9198-82187d42ffb9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 13 - Implement a function to find alternative HPO terms\n",
    "\n",
    "def find_alternative_hpo_terms(phrase, hpo_database=None, k=5):\n",
    "    \"\"\"\n",
    "    Find alternative HPO terms for a clinical phrase\n",
    "    \n",
    "    Args:\n",
    "        phrase: Clinical phrase to match\n",
    "        hpo_database: HPO vector database (optional - will check global scope if None)\n",
    "        k: Number of alternatives to return\n",
    "        \n",
    "    Returns:\n",
    "        List of alternative HPO terms\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Try to use the provided hpo_database or check global scope\n",
    "        if hpo_database is None:\n",
    "            # Check if hpo_db exists in global scope\n",
    "            if 'hpo_db' not in globals():\n",
    "                # Initialize HPO database if we have the embedding file\n",
    "                if 'hpo_embedding_file' in globals() and os.path.exists(hpo_embedding_file):\n",
    "                    print(f\"Initializing HPO database from {hpo_embedding_file}...\")\n",
    "                    from hpomapper_main import HPOVectorDB\n",
    "                    temp_hpo_db = HPOVectorDB(embedding_file=hpo_embedding_file)\n",
    "                    hpo_database = temp_hpo_db\n",
    "                else:\n",
    "                    print(\"HPO database not initialized and no embedding file available.\")\n",
    "                    print(\"Please run the earlier cells to initialize the HPO database.\")\n",
    "                    return []\n",
    "            else:\n",
    "                # Use the global hpo_db\n",
    "                hpo_database = globals()['hpo_db']\n",
    "        \n",
    "        from fuzzywuzzy import fuzz\n",
    "        import numpy as np\n",
    "        \n",
    "        # Get all HPO terms from the database\n",
    "        hpo_items = hpo_database.hpo_data['items']\n",
    "        \n",
    "        if not hpo_items:\n",
    "            print(\"Warning: No HPO terms found in database\")\n",
    "            return []\n",
    "        \n",
    "        # Initialize a list to store matches\n",
    "        matches = []\n",
    "        phrase_lower = phrase.lower()\n",
    "        \n",
    "        print(f\"Searching for matches to: '{phrase}'\")\n",
    "        print(f\"Searching through {len(hpo_items)} HPO terms...\")\n",
    "        \n",
    "        # Calculate fuzzy match scores for all terms\n",
    "        for item in hpo_items:\n",
    "            # Match against the main term\n",
    "            name_lower = item['name'].lower()\n",
    "            \n",
    "            # Use multiple fuzzy matching methods for better accuracy\n",
    "            ratio_score = fuzz.ratio(phrase_lower, name_lower)\n",
    "            token_sort_score = fuzz.token_sort_ratio(phrase_lower, name_lower)\n",
    "            token_set_score = fuzz.token_set_ratio(phrase_lower, name_lower)\n",
    "            \n",
    "            # Take the best score among the different methods\n",
    "            score = max(ratio_score, token_sort_score, token_set_score)\n",
    "            best_method = \"ratio\"\n",
    "            if token_sort_score > ratio_score and token_sort_score >= token_set_score:\n",
    "                best_method = \"token_sort\"\n",
    "            elif token_set_score > ratio_score and token_set_score > token_sort_score:\n",
    "                best_method = \"token_set\"\n",
    "            \n",
    "            # Also check synonyms if available\n",
    "            syn_found = False\n",
    "            best_synonym = None\n",
    "            if 'synonyms' in item and item['synonyms']:\n",
    "                for synonym in item['synonyms']:\n",
    "                    if synonym:\n",
    "                        synonym_lower = synonym.lower()\n",
    "                        syn_ratio_score = fuzz.ratio(phrase_lower, synonym_lower)\n",
    "                        syn_token_sort_score = fuzz.token_sort_ratio(phrase_lower, synonym_lower)\n",
    "                        syn_token_set_score = fuzz.token_set_ratio(phrase_lower, synonym_lower)\n",
    "                        \n",
    "                        # Update score if any synonym has a better match\n",
    "                        syn_score = max(syn_ratio_score, syn_token_sort_score, syn_token_set_score)\n",
    "                        if syn_score > score:\n",
    "                            score = syn_score\n",
    "                            best_method = \"synonym\"\n",
    "                            best_synonym = synonym\n",
    "                            syn_found = True\n",
    "            \n",
    "            # Consider the term a potential match if score is above threshold\n",
    "            if score > 50:  # Only include terms with reasonable similarity\n",
    "                match_info = {\n",
    "                    'hpo_id': item['hpo_id'],\n",
    "                    'name': item['name'],\n",
    "                    'score': score,\n",
    "                    'method': best_method,\n",
    "                    'definition': item.get('definition', 'No definition available'),\n",
    "                    'synonyms': item.get('synonyms', [])\n",
    "                }\n",
    "                \n",
    "                if syn_found and best_synonym:\n",
    "                    match_info['matched_synonym'] = best_synonym\n",
    "                    \n",
    "                matches.append(match_info)\n",
    "        \n",
    "        # Sort by score\n",
    "        matches.sort(key=lambda x: x['score'], reverse=True)\n",
    "        \n",
    "        return matches[:k]\n",
    "    \n",
    "    except ImportError as ie:\n",
    "        if \"fuzzywuzzy\" in str(ie):\n",
    "            print(\"Error: fuzzywuzzy library not installed. Please install with: pip install fuzzywuzzy python-Levenshtein\")\n",
    "        else:\n",
    "            print(f\"Import error: {str(ie)}\")\n",
    "        return []\n",
    "    except Exception as e:\n",
    "        print(f\"Error finding alternative HPO terms: {str(e)}\")\n",
    "        return []\n",
    "\n",
    "# Function to display HPO term details\n",
    "def display_hpo_term_details(term):\n",
    "    \"\"\"Display detailed information about an HPO term\"\"\"\n",
    "    print(f\"\\n{'='*80}\")\n",
    "    print(f\"HPO Term: {term['name']} ({term['hpo_id']})\")\n",
    "    print(f\"Match Score: {term['score']} (using {term['method']} method)\")\n",
    "    \n",
    "    if 'matched_synonym' in term:\n",
    "        print(f\"Matched Synonym: {term['matched_synonym']}\")\n",
    "        \n",
    "    print(f\"Definition: {term['definition']}\")\n",
    "    \n",
    "    if term.get('synonyms'):\n",
    "        print(\"\\nSynonyms:\")\n",
    "        for i, syn in enumerate(term['synonyms']):\n",
    "            if syn:  # Only print non-empty synonyms\n",
    "                print(f\"  {i+1}. {syn}\")\n",
    "    \n",
    "    print(f\"{'='*80}\")\n",
    "\n",
    "# Test with a sample phrase\n",
    "try:\n",
    "    # Check if we have an HPO database initialized\n",
    "    if 'hpo_db' in globals():\n",
    "        sample_phrase = \"Delayed motor development\"\n",
    "        print(f\"Finding alternative HPO terms for: '{sample_phrase}'\")\n",
    "        \n",
    "        # Use the global hpo_db (not passing it as a parameter to avoid naming conflict)\n",
    "        alternatives = find_alternative_hpo_terms(sample_phrase)\n",
    "        \n",
    "        if alternatives:\n",
    "            print(f\"\\nFound {len(alternatives)} alternative HPO terms:\")\n",
    "            for i, alt in enumerate(alternatives):\n",
    "                print(f\"{i+1}. {alt['name']} ({alt['hpo_id']}) - Score: {alt['score']}\")\n",
    "                \n",
    "            # Display detailed information for the top match\n",
    "            print(\"\\nDetails for top match:\")\n",
    "            display_hpo_term_details(alternatives[0])\n",
    "            \n",
    "            # Provide a user interface hint\n",
    "            print(\"\\nTo explore other matches, try:\")\n",
    "            print(\"display_hpo_term_details(alternatives[1])  # Show details for the 2nd match\")\n",
    "        else:\n",
    "            print(\"No matching HPO terms found.\")\n",
    "            \n",
    "    else:\n",
    "        # Try to initialize the HPO database\n",
    "        if 'hpo_embedding_file' in globals() and os.path.exists(hpo_embedding_file):\n",
    "            print(f\"Initializing HPO database from {hpo_embedding_file}...\")\n",
    "            from hpomapper_main import HPOVectorDB\n",
    "            # Create a new global hpo_db variable\n",
    "            globals()['hpo_db'] = HPOVectorDB(embedding_file=hpo_embedding_file)\n",
    "            \n",
    "            # Now try the search\n",
    "            sample_phrase = \"Delayed motor development\"\n",
    "            print(f\"Finding alternative HPO terms for: '{sample_phrase}'\")\n",
    "            \n",
    "            alternatives = find_alternative_hpo_terms(sample_phrase)\n",
    "            \n",
    "            if alternatives:\n",
    "                print(f\"\\nFound {len(alternatives)} alternative HPO terms:\")\n",
    "                for i, alt in enumerate(alternatives):\n",
    "                    print(f\"{i+1}. {alt['name']} ({alt['hpo_id']}) - Score: {alt['score']}\")\n",
    "                \n",
    "                # Display detailed information for the top match\n",
    "                print(\"\\nDetails for top match:\")\n",
    "                display_hpo_term_details(alternatives[0])\n",
    "            else:\n",
    "                print(\"No matching HPO terms found.\")\n",
    "        else:\n",
    "            print(\"HPO database not initialized. Please run the earlier cells to initialize the HPO database.\")\n",
    "except Exception as e:\n",
    "    print(f\"Error testing the HPO term finder: {str(e)}\")\n",
    "    print(\"Please make sure you've run the earlier cells to set up the environment.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66e67353-8f42-44ab-b1c5-f385bb3d3a1c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 14 - Advanced interactive visualization of notes and HPO terms\n",
    "# Let's create an interactive network visualization showing the relationships between notes and HPO terms\n",
    "\n",
    "if not results.empty:\n",
    "    import networkx as nx\n",
    "    import plotly.graph_objects as go\n",
    "    from ipywidgets import interact, FloatSlider, Dropdown, HBox, VBox, Output, HTML\n",
    "    import numpy as np\n",
    "    \n",
    "    # Create a network graph\n",
    "    G = nx.Graph()\n",
    "    \n",
    "    # Add note nodes (what was previously labeled as patient nodes)\n",
    "    for note_id in results['patient_id'].unique():\n",
    "        G.add_node(note_id, type='note')\n",
    "    \n",
    "    # Add HPO term nodes\n",
    "    for hpo_term in results['hpo_term'].unique():\n",
    "        G.add_node(hpo_term, type='hpo_term')\n",
    "    \n",
    "    # Add edges between notes and HPO terms\n",
    "    for _, row in results.iterrows():\n",
    "        G.add_edge(row['patient_id'], row['hpo_term'], weight=row['match_score'])\n",
    "    \n",
    "    # Define node positions using spring layout\n",
    "    pos = nx.spring_layout(G, seed=42, k=0.3)\n",
    "    \n",
    "    # Create interactive visualization using Plotly\n",
    "    def plot_network(min_edge_weight=0.5, layout_type='spring', highlight_node=None):\n",
    "        # Get the appropriate layout\n",
    "        if layout_type == 'spring':\n",
    "            node_pos = nx.spring_layout(G, seed=42, k=0.3)\n",
    "        elif layout_type == 'circular':\n",
    "            node_pos = nx.circular_layout(G)\n",
    "        elif layout_type == 'kamada_kawai':\n",
    "            node_pos = nx.kamada_kawai_layout(G)\n",
    "        elif layout_type == 'random':\n",
    "            node_pos = nx.random_layout(G)\n",
    "        else:\n",
    "            node_pos = pos\n",
    "        \n",
    "        # Separate nodes by type\n",
    "        note_nodes = [node for node in G.nodes() if 'M' in str(node) or 'PT' in str(node)]\n",
    "        hpo_nodes = [node for node in G.nodes() if node not in note_nodes]\n",
    "        \n",
    "        # Extract MRNs for grouping notes by patient\n",
    "        def extract_mrn(note_id):\n",
    "            parts = str(note_id).split('_')\n",
    "            return parts[0] if len(parts) > 0 else note_id\n",
    "        \n",
    "        # Create consistent colors for MRNs\n",
    "        note_mrns = [extract_mrn(node) for node in note_nodes]\n",
    "        unique_mrns = list(set(note_mrns))\n",
    "        \n",
    "        # Generate colors using HSL for better distinction\n",
    "        mrn_colors = {}\n",
    "        for i, mrn in enumerate(unique_mrns):\n",
    "            hue = i / max(1, len(unique_mrns))\n",
    "            mrn_colors[mrn] = f'hsl({int(hue * 360)}, 70%, 60%)'\n",
    "        \n",
    "        # Filter edges based on weight threshold\n",
    "        filtered_edges = [(u, v) for u, v, d in G.edges(data=True) if d['weight'] >= min_edge_weight]\n",
    "        \n",
    "        # Create edge traces\n",
    "        edge_x = []\n",
    "        edge_y = []\n",
    "        \n",
    "        for u, v in filtered_edges:\n",
    "            x0, y0 = node_pos[u]\n",
    "            x1, y1 = node_pos[v]\n",
    "            edge_x.extend([x0, x1, None])\n",
    "            edge_y.extend([y0, y1, None])\n",
    "        \n",
    "        edge_trace = go.Scatter(\n",
    "            x=edge_x, y=edge_y,\n",
    "            line=dict(width=0.7, color='#888'),\n",
    "            hoverinfo='none',\n",
    "            mode='lines',\n",
    "            name='Connections'\n",
    "        )\n",
    "        \n",
    "        # Prepare note nodes data\n",
    "        note_x = []\n",
    "        note_y = []\n",
    "        note_colors = []\n",
    "        note_sizes = []\n",
    "        note_texts = []\n",
    "        \n",
    "        # Identify connected notes\n",
    "        connected_notes = set([u for u, v in filtered_edges if u in note_nodes] + \n",
    "                             [v for u, v in filtered_edges if v in note_nodes])\n",
    "        \n",
    "        for node in note_nodes:\n",
    "            x, y = node_pos[node]\n",
    "            note_x.append(x)\n",
    "            note_y.append(y)\n",
    "            \n",
    "            # Color by MRN\n",
    "            mrn = extract_mrn(node)\n",
    "            color = mrn_colors.get(mrn, 'lightgray')\n",
    "            note_colors.append(color)\n",
    "            \n",
    "            # Size based on number of connections\n",
    "            connections = [v for u, v in filtered_edges if u == node]\n",
    "            node_size = 15 + min(20, len(connections) * 2)\n",
    "            note_sizes.append(node_size)\n",
    "            \n",
    "            # Create hover text\n",
    "            if '_' in str(node):\n",
    "                mrn, note_idx = str(node).split('_', 1)\n",
    "                hover_text = f\"Note ID: {node}\\nMRN: {mrn}\\nNote Index: {note_idx}\"\n",
    "            else:\n",
    "                hover_text = f\"Note ID: {node}\"\n",
    "            \n",
    "            hover_text += f\"\\nConnected HPO terms: {len(connections)}\"\n",
    "            note_texts.append(hover_text)\n",
    "        \n",
    "        # Create note node trace\n",
    "        note_trace = go.Scatter(\n",
    "            x=note_x, y=note_y,\n",
    "            mode='markers',\n",
    "            hoverinfo='text',\n",
    "            marker=dict(\n",
    "                color=note_colors,\n",
    "                size=note_sizes,\n",
    "                line=dict(width=1, color='darkgray'),\n",
    "                opacity=[1.0 if node in connected_notes else 0.4 for node in note_nodes]\n",
    "            ),\n",
    "            text=note_texts,\n",
    "            name='Clinical Notes'\n",
    "        )\n",
    "        \n",
    "        # Prepare HPO nodes data\n",
    "        hpo_x = []\n",
    "        hpo_y = []\n",
    "        hpo_sizes = []\n",
    "        hpo_texts = []\n",
    "        \n",
    "        # Identify connected HPO terms\n",
    "        connected_hpo = set([u for u, v in filtered_edges if u in hpo_nodes] + \n",
    "                           [v for u, v in filtered_edges if v in hpo_nodes])\n",
    "        \n",
    "        for node in hpo_nodes:\n",
    "            x, y = node_pos[node]\n",
    "            hpo_x.append(x)\n",
    "            hpo_y.append(y)\n",
    "            \n",
    "            # Size based on number of connections\n",
    "            connections = [u for u, v in filtered_edges if v == node]\n",
    "            node_size = 10 + min(15, len(connections) * 1.5)\n",
    "            hpo_sizes.append(node_size)\n",
    "            \n",
    "            # Create hover text\n",
    "            hover_text = f\"HPO Term: {node}\\nConnected notes: {len(connections)}\"\n",
    "            hpo_texts.append(hover_text)\n",
    "        \n",
    "        # Create HPO node trace\n",
    "        hpo_trace = go.Scatter(\n",
    "            x=hpo_x, y=hpo_y,\n",
    "            mode='markers',\n",
    "            hoverinfo='text',\n",
    "            marker=dict(\n",
    "                color='#66CD00',  # Green color for HPO terms\n",
    "                size=hpo_sizes,\n",
    "                symbol='diamond',\n",
    "                line=dict(width=1, color='darkgreen'),\n",
    "                opacity=[1.0 if node in connected_hpo else 0.4 for node in hpo_nodes]\n",
    "            ),\n",
    "            text=hpo_texts,\n",
    "            name='HPO Terms'\n",
    "        )\n",
    "        \n",
    "        # Create labels for notes\n",
    "        note_labels = go.Scatter(\n",
    "            x=note_x, y=note_y,\n",
    "            mode='text',\n",
    "            text=[str(node).split('_')[0] + '...' for node in note_nodes],  # Show MRN part\n",
    "            textposition=\"top center\",\n",
    "            textfont=dict(\n",
    "                family=\"Arial\",\n",
    "                size=8,\n",
    "                color=\"darkblue\"\n",
    "            ),\n",
    "            hoverinfo='none',\n",
    "            showlegend=False\n",
    "        )\n",
    "        \n",
    "        # Create labels for HPO terms\n",
    "        hpo_labels = go.Scatter(\n",
    "            x=hpo_x, y=hpo_y,\n",
    "            mode='text',\n",
    "            text=[str(node)[:15] + '...' if len(str(node)) > 15 else str(node) for node in hpo_nodes],\n",
    "            textposition=\"top center\",\n",
    "            textfont=dict(\n",
    "                family=\"Arial\",\n",
    "                size=7,\n",
    "                color=\"darkgreen\"\n",
    "            ),\n",
    "            hoverinfo='none',\n",
    "            showlegend=False\n",
    "        )\n",
    "        \n",
    "        # Highlight specific node if requested\n",
    "        highlight_traces = []\n",
    "        if highlight_node and highlight_node in G.nodes():\n",
    "            # Find connected nodes meeting weight threshold\n",
    "            highlight_connections = []\n",
    "            for neighbor in G.neighbors(highlight_node):\n",
    "                if G.has_edge(highlight_node, neighbor):\n",
    "                    edge_data = G.get_edge_data(highlight_node, neighbor)\n",
    "                    if edge_data['weight'] >= min_edge_weight:\n",
    "                        highlight_connections.append(neighbor)\n",
    "            \n",
    "            # Create trace for highlighted node\n",
    "            highlight_trace = go.Scatter(\n",
    "                x=[node_pos[highlight_node][0]],\n",
    "                y=[node_pos[highlight_node][1]],\n",
    "                mode='markers',\n",
    "                marker=dict(\n",
    "                    color='red',\n",
    "                    size=20,\n",
    "                    line=dict(width=2, color='darkred')\n",
    "                ),\n",
    "                text=f\"Selected: {highlight_node}\",\n",
    "                name='Selected Node',\n",
    "                hoverinfo='text'\n",
    "            )\n",
    "            highlight_traces.append(highlight_trace)\n",
    "            \n",
    "            # Create trace for connected nodes\n",
    "            if highlight_connections:\n",
    "                connected_x = [node_pos[node][0] for node in highlight_connections]\n",
    "                connected_y = [node_pos[node][1] for node in highlight_connections]\n",
    "                \n",
    "                connected_trace = go.Scatter(\n",
    "                    x=connected_x, y=connected_y,\n",
    "                    mode='markers',\n",
    "                    marker=dict(\n",
    "                        color='orange',\n",
    "                        size=16,\n",
    "                        line=dict(width=2, color='darkorange')\n",
    "                    ),\n",
    "                    text=[f\"Connected to selected: {node}\" for node in highlight_connections],\n",
    "                    name='Connected to Selection',\n",
    "                    hoverinfo='text'\n",
    "                )\n",
    "                highlight_traces.append(connected_trace)\n",
    "                \n",
    "                # Highlight the edges\n",
    "                highlight_edge_x = []\n",
    "                highlight_edge_y = []\n",
    "                \n",
    "                for neighbor in highlight_connections:\n",
    "                    x0, y0 = node_pos[highlight_node]\n",
    "                    x1, y1 = node_pos[neighbor]\n",
    "                    highlight_edge_x.extend([x0, x1, None])\n",
    "                    highlight_edge_y.extend([y0, y1, None])\n",
    "                \n",
    "                highlight_edge_trace = go.Scatter(\n",
    "                    x=highlight_edge_x, y=highlight_edge_y,\n",
    "                    line=dict(width=2, color='orange'),\n",
    "                    hoverinfo='none',\n",
    "                    mode='lines',\n",
    "                    name='Highlighted Connections'\n",
    "                )\n",
    "                highlight_traces.append(highlight_edge_trace)\n",
    "        \n",
    "        # Combine all traces\n",
    "        traces = [edge_trace, note_trace, hpo_trace, note_labels, hpo_labels] + highlight_traces\n",
    "        \n",
    "        # Create figure\n",
    "        fig = go.Figure(data=traces)\n",
    "        \n",
    "        # Count connected nodes\n",
    "        connected_note_count = len(set([u for u, v in filtered_edges if u in note_nodes] + \n",
    "                                      [v for u, v in filtered_edges if v in note_nodes]))\n",
    "        connected_hpo_count = len(set([u for u, v in filtered_edges if u in hpo_nodes] + \n",
    "                                     [v for u, v in filtered_edges if v in hpo_nodes]))\n",
    "        \n",
    "        # Update layout\n",
    "        fig.update_layout(\n",
    "            title=dict(\n",
    "                text=f\"Network of Clinical Notes and HPO Terms (min score: {min_edge_weight})\",\n",
    "                font=dict(size=16)\n",
    "            ),\n",
    "            showlegend=True,\n",
    "            hovermode='closest',\n",
    "            margin=dict(b=20, l=5, r=5, t=40),\n",
    "            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
    "            height=600,\n",
    "            width=800,\n",
    "            plot_bgcolor='white',\n",
    "            legend=dict(\n",
    "                yanchor=\"top\",\n",
    "                y=0.99,\n",
    "                xanchor=\"right\",\n",
    "                x=0.99,\n",
    "                bgcolor=\"rgba(255, 255, 255, 0.8)\"\n",
    "            )\n",
    "        )\n",
    "        \n",
    "        # Add annotations for network statistics\n",
    "        fig.add_annotation(\n",
    "            xref=\"paper\", yref=\"paper\",\n",
    "            x=0.01, y=0.01,\n",
    "            text=(f\"Notes: {len(note_nodes)} | HPO Terms: {len(hpo_nodes)} | \" \n",
    "                  f\"Connected: {connected_note_count + connected_hpo_count} | \"\n",
    "                  f\"Edges: {len(filtered_edges)}\"),\n",
    "            showarrow=False,\n",
    "            font=dict(size=12),\n",
    "            bgcolor=\"rgba(255, 255, 255, 0.8)\",\n",
    "            bordercolor=\"black\",\n",
    "            borderwidth=1,\n",
    "            borderpad=4\n",
    "        )\n",
    "        \n",
    "        return fig\n",
    "    \n",
    "    # Create interactive widgets\n",
    "    weight_slider = FloatSlider(\n",
    "        value=0.5,\n",
    "        min=0,\n",
    "        max=1,\n",
    "        step=0.1,\n",
    "        description='Min Match Score:',\n",
    "        disabled=False,\n",
    "        continuous_update=False,\n",
    "        orientation='horizontal',\n",
    "        readout=True,\n",
    "        readout_format='.1f',\n",
    "    )\n",
    "    \n",
    "    layout_dropdown = Dropdown(\n",
    "        options=[\n",
    "            ('Spring', 'spring'), \n",
    "            ('Circular', 'circular'), \n",
    "            ('Kamada-Kawai', 'kamada_kawai'),\n",
    "            ('Random', 'random')\n",
    "        ],\n",
    "        value='spring',\n",
    "        description='Layout:',\n",
    "        disabled=False,\n",
    "    )\n",
    "    \n",
    "    # Get all nodes for the highlight dropdown\n",
    "    all_nodes = list(G.nodes())\n",
    "    all_nodes.insert(0, None)  # Add None option\n",
    "    \n",
    "    node_dropdown = Dropdown(\n",
    "        options=all_nodes,\n",
    "        value=None,\n",
    "        description='Highlight Node:',\n",
    "        disabled=False,\n",
    "        layout={'width': 'max-content'}\n",
    "    )\n",
    "    \n",
    "    # Create output for the plot\n",
    "    plot_output = Output()\n",
    "    \n",
    "    # Function to update the plot\n",
    "    def update_plot(min_edge_weight, layout_type, highlight_node):\n",
    "        with plot_output:\n",
    "            plot_output.clear_output(wait=True)\n",
    "            fig = plot_network(min_edge_weight, layout_type, highlight_node)\n",
    "            fig.show()\n",
    "    \n",
    "    # Display controls and plot\n",
    "    controls = HBox([weight_slider, layout_dropdown, node_dropdown])\n",
    "    display(VBox([\n",
    "        HTML(\"<h3>Interactive Network Visualization: Clinical Notes and HPO Terms</h3>\"),\n",
    "        HTML(\"<p>This visualization shows the relationship between clinical notes (colored circles) and HPO terms (green diamonds).</p>\"),\n",
    "        HTML(\"<p>Each colored circle represents a clinical note (MRN + note_index), not a unique patient. Notes with the same MRN share similar colors.</p>\"),\n",
    "        HTML(\"<p>Use the controls below to adjust the visualization:</p>\"),\n",
    "        controls,\n",
    "        plot_output\n",
    "    ]))\n",
    "    \n",
    "    # Connect the widgets to the update function\n",
    "    interact(update_plot, \n",
    "             min_edge_weight=weight_slider, \n",
    "             layout_type=layout_dropdown,\n",
    "             highlight_node=node_dropdown)\n",
    "    \n",
    "    # Print some network statistics\n",
    "    print(f\"\\nNetwork summary:\")\n",
    "    print(f\"Number of nodes: {G.number_of_nodes()}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c9430929-ff98-407d-9c9e-a5d1f0cc5dcd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 15 - Export results to various formats\n",
    "if not results.empty:\n",
    "    # Create output directory if it doesn't exist\n",
    "    output_dir = \"hpomapper_output\"\n",
    "    os.makedirs(output_dir, exist_ok=True)\n",
    "    \n",
    "    # Export to CSV (already done, but let's save to the output directory)\n",
    "    csv_file = os.path.join(output_dir, \"hpomapper_results.csv\")\n",
    "    results.to_csv(csv_file, index=False)\n",
    "    print(f\"Results exported to CSV: {csv_file}\")\n",
    "    \n",
    "    # Export to Excel\n",
    "    excel_file = os.path.join(output_dir, \"hpomapper_results.xlsx\")\n",
    "    results.to_excel(excel_file, index=False)\n",
    "    print(f\"Results exported to Excel: {excel_file}\")\n",
    "    \n",
    "    # Export to JSON\n",
    "    json_file = os.path.join(output_dir, \"hpomapper_results.json\")\n",
    "    results.to_json(json_file, orient=\"records\", indent=2)\n",
    "    print(f\"Results exported to JSON: {json_file}\")\n",
    "    \n",
    "    # Create a summary report\n",
    "    summary_file = os.path.join(output_dir, \"hpomapper_summary.txt\")\n",
    "    with open(summary_file, \"w\") as f:\n",
    "        f.write(\"hpomapper Summary Report\\n\")\n",
    "        f.write(\"=======================\\n\\n\")\n",
    "        f.write(f\"Report generated on: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n",
    "        \n",
    "        f.write(\"Overview:\\n\")\n",
    "        f.write(f\"- Total patients: {results['patient_id'].nunique()}\\n\")\n",
    "        f.write(f\"- Total HPO terms extracted: {len(results)}\\n\")\n",
    "        f.write(f\"- Unique HPO terms: {results['hpo_term'].nunique()}\\n\\n\")\n",
    "        \n",
    "        f.write(\"HPO terms per patient:\\n\")\n",
    "        for patient, count in results.groupby('patient_id').size().items():\n",
    "            f.write(f\"- {patient}: {count} terms\\n\")\n",
    "        \n",
    "        f.write(\"\\nTop HPO terms:\\n\")\n",
    "        for term, count in results['hpo_term'].value_counts().head(10).items():\n",
    "            f.write(f\"- {term}: {count} occurrences\\n\")\n",
    "            \n",
    "        f.write(\"\\nMatch score statistics:\\n\")\n",
    "        f.write(f\"- Average match score: {results['match_score'].mean():.2f}\\n\")\n",
    "        f.write(f\"- Minimum match score: {results['match_score'].min():.2f}\\n\")\n",
    "        f.write(f\"- Maximum match score: {results['match_score'].max():.2f}\\n\")\n",
    "        \n",
    "    print(f\"Summary report created: {summary_file}\")\n",
    "    \n",
    "    # Generate HTML report with interactive visualizations if Plotly is available\n",
    "    try:\n",
    "        import plotly.express as px\n",
    "        import plotly.graph_objects as go\n",
    "        from plotly.subplots import make_subplots\n",
    "        \n",
    "        html_file = os.path.join(output_dir, \"hpomapper_report.html\")\n",
    "        \n",
    "        # Create a more detailed HTML report with interactive visualizations\n",
    "        with open(html_file, \"w\") as f:\n",
    "            f.write(\"<html>\\n<head>\\n\")\n",
    "            f.write(\"<title>hpomapper Results Report</title>\\n\")\n",
    "            f.write(\"<style>\\n\")\n",
    "            f.write(\"body { font-family: Arial, sans-serif; margin: 40px; }\\n\")\n",
    "            f.write(\"h1 { color: #2c3e50; }\\n\")\n",
    "            f.write(\"h2 { color: #3498db; }\\n\")\n",
    "            f.write(\"table { border-collapse: collapse; width: 100%; }\\n\")\n",
    "            f.write(\"th, td { text-align: left; padding: 8px; border: 1px solid #ddd; }\\n\")\n",
    "            f.write(\"tr:nth-child(even) { background-color: #f2f2f2; }\\n\")\n",
    "            f.write(\"th { background-color: #3498db; color: white; }\\n\")\n",
    "            f.write(\".container { margin-bottom: 30px; }\\n\")\n",
    "            f.write(\"</style>\\n\")\n",
    "            f.write(\"</head>\\n<body>\\n\")\n",
    "            \n",
    "            # Header\n",
    "            f.write(f\"<h1>hpomapper Results Report</h1>\\n\")\n",
    "            f.write(f\"<p>Report generated on: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}</p>\\n\")\n",
    "            \n",
    "            # Summary\n",
    "            f.write(\"<div class='container'>\\n\")\n",
    "            f.write(\"<h2>Summary</h2>\\n\")\n",
    "            f.write(\"<ul>\\n\")\n",
    "            f.write(f\"<li>Total patients: {results['patient_id'].nunique()}</li>\\n\")\n",
    "            f.write(f\"<li>Total HPO terms extracted: {len(results)}</li>\\n\")\n",
    "            f.write(f\"<li>Unique HPO terms: {results['hpo_term'].nunique()}</li>\\n\")\n",
    "            f.write(f\"<li>Average match score: {results['match_score'].mean():.2f}</li>\\n\")\n",
    "            f.write(\"</ul>\\n\")\n",
    "            f.write(\"</div>\\n\")\n",
    "            \n",
    "            # Embed the Plotly charts\n",
    "            # Since we're writing to a standalone HTML file, we need to include the full Plotly output\n",
    "            \n",
    "            # Terms per patient chart\n",
    "            patient_counts = results.groupby('patient_id').size().reset_index(name='count')\n",
    "            fig1 = px.bar(patient_counts, x='patient_id', y='count', \n",
    "                         title='HPO Terms per Patient',\n",
    "                         labels={'count': 'Number of Terms', 'patient_id': 'Patient ID'})\n",
    "            f.write(\"<div class='container'>\\n\")\n",
    "            f.write(\"<h2>HPO Terms per Patient</h2>\\n\")\n",
    "            f.write(fig1.to_html(full_html=False, include_plotlyjs='cdn'))\n",
    "            f.write(\"</div>\\n\")\n",
    "            \n",
    "            # Top HPO terms chart\n",
    "            term_counts = results['hpo_term'].value_counts().reset_index()\n",
    "            term_counts.columns = ['hpo_term', 'count']\n",
    "            term_counts = term_counts.head(10)\n",
    "            fig2 = px.bar(term_counts, y='hpo_term', x='count', \n",
    "                         title='Top 10 HPO Terms',\n",
    "                         labels={'count': 'Occurrences', 'hpo_term': 'HPO Term'})\n",
    "            f.write(\"<div class='container'>\\n\")\n",
    "            f.write(\"<h2>Top 10 HPO Terms</h2>\\n\")\n",
    "            f.write(fig2.to_html(full_html=False, include_plotlyjs='cdn'))\n",
    "            f.write(\"</div>\\n\")\n",
    "            \n",
    "            # Match score distribution\n",
    "            fig3 = px.histogram(results, x='match_score', nbins=20,\n",
    "                               title='Distribution of Match Scores',\n",
    "                               labels={'match_score': 'Match Score', 'count': 'Frequency'})\n",
    "            f.write(\"<div class='container'>\\n\")\n",
    "            f.write(\"<h2>Match Score Distribution</h2>\\n\")\n",
    "            f.write(fig3.to_html(full_html=False, include_plotlyjs='cdn'))\n",
    "            f.write(\"</div>\\n\")\n",
    "            \n",
    "            # Heatmap of patient-HPO term relationships\n",
    "            if len(results) > 0 and results['patient_id'].nunique() > 1 and results['hpo_term'].nunique() > 1:\n",
    "                # Create a pivot table for the heatmap\n",
    "                pivot_df = results.pivot_table(index='patient_id', columns='hpo_term', \n",
    "                                              values='match_score', aggfunc='mean', fill_value=0)\n",
    "                \n",
    "                # Create the heatmap\n",
    "                fig4 = go.Figure(data=go.Heatmap(\n",
    "                    z=pivot_df.values,\n",
    "                    x=pivot_df.columns,\n",
    "                    y=pivot_df.index,\n",
    "                    colorscale='Viridis',\n",
    "                    colorbar=dict(title='Match Score')\n",
    "                ))\n",
    "                \n",
    "                fig4.update_layout(\n",
    "                    title='Patient-HPO Term Relationship Heatmap',\n",
    "                    xaxis_title='HPO Term',\n",
    "                    yaxis_title='Patient ID'\n",
    "                )\n",
    "                \n",
    "                f.write(\"<div class='container'>\\n\")\n",
    "                f.write(\"<h2>Patient-HPO Term Relationship Heatmap</h2>\\n\")\n",
    "                f.write(fig4.to_html(full_html=False, include_plotlyjs='cdn'))\n",
    "                f.write(\"</div>\\n\")\n",
    "            \n",
    "            # Results table\n",
    "            f.write(\"<div class='container'>\\n\")\n",
    "            f.write(\"<h2>Detailed Results</h2>\\n\")\n",
    "            f.write(\"<table>\\n\")\n",
    "            f.write(\"<tr><th>Patient ID</th><th>Clinical Phrase</th><th>HPO Term</th><th>HPO ID</th><th>Match Score</th></tr>\\n\")\n",
    "            \n",
    "            for _, row in results.iterrows():\n",
    "                f.write(f\"<tr><td>{row['patient_id']}</td><td>{row['clinical_phrase']}</td>\")\n",
    "                f.write(f\"<td>{row['hpo_term']}</td><td>{row['hpo_id']}</td>\")\n",
    "                f.write(f\"<td>{row['match_score']:.2f}</td></tr>\\n\")\n",
    "                \n",
    "            f.write(\"</table>\\n\")\n",
    "            f.write(\"</div>\\n\")\n",
    "            \n",
    "            # Footer\n",
    "            f.write(\"<div class='container'>\\n\")\n",
    "            f.write(\"<p><em>This report was automatically generated by hpomapper.</em></p>\\n\")\n",
    "            f.write(\"<p><em>hpomapper extracts Human Phenotype Ontology (HPO) terms from clinical notes.</em></p>\\n\")\n",
    "            f.write(\"</div>\\n\")\n",
    "            \n",
    "            f.write(\"</body>\\n</html>\")\n",
    "            \n",
    "        print(f\"Interactive HTML report created: {html_file}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print(\"Plotly not available. Interactive HTML report not created.\")\n",
    "        \n",
    "    # Export a simple HTML version (without Plotly) as a fallback\n",
    "    try:\n",
    "        simple_html_file = os.path.join(output_dir, \"hpomapper_results_simple.html\")\n",
    "        \n",
    "        with open(simple_html_file, \"w\") as f:\n",
    "            f.write(\"<html>\\n<head>\\n\")\n",
    "            f.write(\"<title>hpomapper Results</title>\\n\")\n",
    "            f.write(\"<style>\\n\")\n",
    "            f.write(\"body { font-family: Arial, sans-serif; margin: 40px; }\\n\")\n",
    "            f.write(\"h1 { color: #2c3e50; }\\n\")\n",
    "            f.write(\"h2 { color: #3498db; }\\n\")\n",
    "            f.write(\"table { border-collapse: collapse; width: 100%; }\\n\")\n",
    "            f.write(\"th, td { text-align: left; padding: 8px; border: 1px solid #ddd; }\\n\")\n",
    "            f.write(\"tr:nth-child(even) { background-color: #f2f2f2; }\\n\")\n",
    "            f.write(\"th { background-color: #3498db; color: white; }\\n\")\n",
    "            f.write(\"</style>\\n\")\n",
    "            f.write(\"</head>\\n<body>\\n\")\n",
    "            \n",
    "            f.write(\"<h1>hpomapper Results</h1>\\n\")\n",
    "            f.write(f\"<p>Report generated on: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}</p>\\n\")\n",
    "            \n",
    "            f.write(\"<h2>Summary</h2>\\n\")\n",
    "            f.write(\"<ul>\\n\")\n",
    "            f.write(f\"<li>Total patients: {results['patient_id'].nunique()}</li>\\n\")\n",
    "            f.write(f\"<li>Total HPO terms extracted: {len(results)}</li>\\n\")\n",
    "            f.write(f\"<li>Unique HPO terms: {results['hpo_term'].nunique()}</li>\\n\")\n",
    "            f.write(\"</ul>\\n\")\n",
    "            \n",
    "            f.write(\"<h2>Results Table</h2>\\n\")\n",
    "            f.write(\"<table>\\n\")\n",
    "            f.write(\"<tr><th>Patient ID</th><th>Clinical Phrase</th><th>HPO Term</th><th>HPO ID</th><th>Match Score</th><th>Definition</th></tr>\\n\")\n",
    "            \n",
    "            for _, row in results.iterrows():\n",
    "                f.write(f\"<tr><td>{row['patient_id']}</td><td>{row['clinical_phrase']}</td>\")\n",
    "                f.write(f\"<td>{row['hpo_term']}</td><td>{row['hpo_id']}</td>\")\n",
    "                f.write(f\"<td>{row['match_score']:.2f}</td><td>{row['definition']}</td></tr>\\n\")\n",
    "                \n",
    "            f.write(\"</table>\\n\")\n",
    "            f.write(\"</body>\\n</html>\")\n",
    "            \n",
    "        print(f\"Simple HTML report created: {simple_html_file}\")\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"Error creating simple HTML report: {str(e)}\")\n",
    "    \n",
    "    print(\"\\nExport complete. All results saved to the 'hpomapper_output' directory.\")\n",
    "else:\n",
    "    print(\"No results to export. Please run hpomapper first.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3131b6f9-b063-4a21-992d-3a51a71ed60e",
   "metadata": {},
   "source": [
    "\n",
    "\n",
    "## 6. Conclusion\n",
    "\n",
    "We've demonstrated the hpomapper workflow:\n",
    "\n",
    "1. Setting up the environment\n",
    "2. Running hpomapper on clinical notes\n",
    "3. Analyzing and visualizing the results\n",
    "\n",
    "In a production environment, you would:\n",
    "\n",
    "- Process real clinical notes (larger datasets)\n",
    "- Implement a more sophisticated review and validation process\n",
    "- Integrate with your clinical data systems\n",
    "\n",
    "hpomapper provides a powerful framework for standardizing phenotypic descriptions\n",
    "in clinical notes, which can be valuable for genomic analysis, disease classification,\n",
    "and precision medicine initiatives."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a5e8a0ed-5950-4d7f-a152-9b01a701f05f",
   "metadata": {},
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.21"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
